var documenterSearchIndex = {"docs":
[{"location":"api/io/#I/O-Functions","page":"I/O Functions","title":"I/O Functions","text":"","category":"section"},{"location":"api/io/#Loading-Shape-Models","page":"I/O Functions","title":"Loading Shape Models","text":"","category":"section"},{"location":"api/io/#AsteroidShapeModels.load_shape_obj","page":"I/O Functions","title":"AsteroidShapeModels.load_shape_obj","text":"load_shape_obj(shapepath; scale=1.0, with_face_visibility=false) -> ShapeModel\n\nLoad a shape model from a Wavefront OBJ file.\n\nArguments\n\nshapepath::String: Path to a Wavefront OBJ file\n\nKeyword Arguments\n\nscale::Real=1.0: Scale factor of the shape model\nwith_face_visibility::Bool=false: Whether to compute face-to-face visibility\n\nReturns\n\nShapeModel: Loaded shape model with computed geometric properties\n\nExamples\n\n# Load a shape model\nshape = load_shape_obj(\"asteroid.obj\")\n\n# Load with scaling and visibility computation\nshape = load_shape_obj(\"asteroid_km.obj\", scale=1000, with_face_visibility=true)\n\nSee also: load_shape_grid, loadobj\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.loadobj","page":"I/O Functions","title":"AsteroidShapeModels.loadobj","text":"loadobj(shapepath::String; scale=1, message=true) -> nodes, faces\n\nLoad a 3D shape model from an OBJ file.\n\nArguments\n\nshapepath::String: Path to the OBJ file\n\nKeyword Arguments\n\nscale::Real=1: Scale factor to apply to all vertex coordinates. For example, use scale=1000 to convert from kilometers to meters\nmessage::Bool=true: Whether to print loading information\n\nReturns\n\nnodes::Vector{SVector{3,Float64}}: Array of vertex positions\nfaces::Vector{SVector{3,Int64}}: Array of triangular face definitions (1-indexed vertex indices)\n\nExamples\n\n# Load shape model in meters\nnodes, faces = loadobj(\"asteroid.obj\")\n\n# Load shape model and convert from km to m\nnodes, faces = loadobj(\"asteroid_km.obj\", scale=1000)\n\n# Load without printing messages\nnodes, faces = loadobj(\"asteroid.obj\", message=false)\n\nNotes\n\nThis function uses the FileIO/MeshIO packages to load OBJ files. Only triangular faces are supported.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.isobj","page":"I/O Functions","title":"AsteroidShapeModels.isobj","text":"isobj(filepath::String) -> Bool\n\nCheck if a file has the OBJ file extension.\n\nArguments\n\nfilepath::String: Path to the file to check\n\nReturns\n\nBool: true if the file has .obj extension, false otherwise\n\nExamples\n\nisobj(\"model.obj\")    # Returns true\nisobj(\"model.stl\")    # Returns false\nisobj(\"model.OBJ\")    # Returns false (case-sensitive)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Grid-Loading","page":"I/O Functions","title":"Grid Loading","text":"","category":"section"},{"location":"api/io/#AsteroidShapeModels.load_shape_grid","page":"I/O Functions","title":"AsteroidShapeModels.load_shape_grid","text":"load_shape_grid(xs, ys, zs; scale=1.0, with_face_visibility=false) -> ShapeModel\n\nConvert a regular grid (x, y) with z-values to a shape model.\n\nArguments\n\nxs::AbstractVector: x-coordinates of grid points\nys::AbstractVector: y-coordinates of grid points\nzs::AbstractMatrix: z-coordinates of grid points where zs[i,j] corresponds to (xs[i], ys[j])\n\nKeyword Arguments\n\nscale::Real=1.0: Scale factor to apply to all coordinates\nwith_face_visibility::Bool=false: Whether to compute face-to-face visibility\n\nReturns\n\nShapeModel: Shape model with computed geometric properties\n\nExamples\n\n# Create a shape from elevation data\nxs = range(-10, 10, length=50)\nys = range(-10, 10, length=50)\nzs = [exp(-(x^2 + y^2)/10) for x in xs, y in ys]  # Gaussian surface\nshape = load_shape_grid(xs, ys, zs)\n\n# With scaling and visibility\nshape = load_shape_grid(xs, ys, zs, scale=1000, with_face_visibility=true)\n\nSee also: load_shape_obj, grid_to_faces\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.grid_to_faces","page":"I/O Functions","title":"AsteroidShapeModels.grid_to_faces","text":"grid_to_faces(xs::AbstractVector, ys::AbstractVector, zs::AbstractMatrix) -> nodes, faces\n\nConvert a regular grid (x, y) and corresponding z-coordinates to triangular facets.\n\n| ⧹| ⧹| ⧹|\n\nj+1 ・–C–D–・     |⧹ |⧹ |⧹ |     | ⧹| ⧹| ⧹| j   ・–A–B–・     |⧹ |⧹ |⧹ |        i  i+1\n\nArguments\n\nxs::AbstractVector: x-coordinates of grid points (should be sorted)\nys::AbstractVector: y-coordinates of grid points (should be sorted)\nzs::AbstractMatrix: z-coordinates of grid points where zs[i,j] corresponds to (xs[i], ys[j])\n\nReturns\n\nnodes::Vector{SVector{3,Float64}}: Array of 3D vertex positions\nfaces::Vector{SVector{3,Int}}: Array of triangular face definitions (1-indexed)\n\nNotes\n\nEach grid cell is divided into two triangles. The vertices are numbered sequentially row by row (j varies slowest).\n\nExamples\n\n# Create a simple 3x3 grid\nxs = [0.0, 1.0, 2.0]\nys = [0.0, 1.0, 2.0]\nzs = [i + j for i in 1:3, j in 1:3]  # z = x + y\nnodes, faces = grid_to_faces(xs, ys, zs)\n\nSee also: load_shape_grid\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#Visibility-Analysis","page":"Visibility Analysis","title":"Visibility Analysis","text":"","category":"section"},{"location":"api/visibility/#Main-Functions","page":"Visibility Analysis","title":"Main Functions","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.build_face_visibility_graph!","page":"Visibility Analysis","title":"AsteroidShapeModels.build_face_visibility_graph!","text":"build_face_visibility_graph!(shape::ShapeModel)\n\nBuild face-to-face visibility graph for the shape model.\n\nThis function computes which faces are visible from each face and stores the results in a FaceVisibilityGraph structure using CSR (Compressed Sparse Row) format.\n\nArguments\n\nshape : Shape model of an asteroid\n\nNotes\n\nThe visibility graph is stored in shape.face_visibility_graph\nThis is a computationally intensive operation, especially for large models\nThe resulting graph contains view factors, distances, and direction vectors\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.isilluminated","page":"Visibility Analysis","title":"AsteroidShapeModels.isilluminated","text":"isilluminated(shape::ShapeModel, r☉::StaticVector{3}, i::Integer) -> Bool\n\nReturn if the i-th face of the shape model is illuminated by the direct sunlight or not\n\nArguments\n\nshape : Shape model of an asteroid\nr☉    : Sun's position in the asteroid-fixed frame, which doesn't have to be normalized.\ni     : Index of the face to be checked\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.view_factor","page":"Visibility Analysis","title":"AsteroidShapeModels.view_factor","text":"view_factor(cᵢ, cⱼ, n̂ᵢ, n̂ⱼ, aⱼ) -> fᵢⱼ, dᵢⱼ, d̂ᵢⱼ\n\nCalculate the view factor from face i to face j, assuming Lambertian emission.\n\nArguments\n\ncᵢ::StaticVector{3}: Center position of face i\ncⱼ::StaticVector{3}: Center position of face j\nn̂ᵢ::StaticVector{3}: Unit normal vector of face i\nn̂ⱼ::StaticVector{3}: Unit normal vector of face j\naⱼ::Real           : Area of face j\n\nReturns\n\nfᵢⱼ::Real: View factor from face i to face j\ndᵢⱼ::Real: Distance between face centers\nd̂ᵢⱼ::StaticVector{3}: Unit direction vector from face i to face j\n\nNotes\n\nThe view factor is calculated using the formula:\n\nfᵢⱼ = (cosθᵢ * cosθⱼ) / (π * dᵢⱼ²) * aⱼ\n\nwhere θᵢ and θⱼ are the angles between the line connecting the faces and the respective normal vectors.\n\nThe view factor is automatically zero when:\n\nFace i is facing away from face j (cosθᵢ ≤ 0)\nFace j is facing away from face i (cosθⱼ ≤ 0)\nBoth conditions ensure that only mutually visible faces have non-zero view factors\n\nVisual representation\n\n(i)   fᵢⱼ   (j)\n △    -->    △\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#FaceVisibilityGraph-Functions","page":"Visibility Analysis","title":"FaceVisibilityGraph Functions","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_indices","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_indices","text":"get_visible_face_indices(graph::FaceVisibilityGraph, face_id::Int) -> SubArray\n\nGet indices of faces visible from the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_view_factors","page":"Visibility Analysis","title":"AsteroidShapeModels.get_view_factors","text":"get_view_factors(graph::FaceVisibilityGraph, face_id::Int) -> SubArray\n\nGet view factors for the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_distances","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_distances","text":"get_visible_face_distances(graph::FaceVisibilityGraph, face_id::Int) -> SubArray\n\nGet distances to visible faces from the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_directions","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_directions","text":"get_visible_face_directions(graph::FaceVisibilityGraph, face_id::Int) -> SubArray\n\nGet direction vectors to visible faces from the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_data","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_data","text":"get_visible_face_data(graph::FaceVisibilityGraph, face_id::Int, idx::Int)\n\nGet the idx-th visible face data for the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.num_visible_faces","page":"Visibility Analysis","title":"AsteroidShapeModels.num_visible_faces","text":"num_visible_faces(graph::FaceVisibilityGraph, face_id::Int) -> Int\n\nGet the number of visible faces for the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Core-Types","page":"Types","title":"Core Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.ShapeModel","page":"Types","title":"AsteroidShapeModels.ShapeModel","text":"ShapeModel\n\nA polyhedral shape model of an asteroid.\n\nFields\n\nnodes         : Vector of node positions\nfaces         : Vector of vertex indices of faces\nface_centers  : Center position of each face\nface_normals  : Normal vector of each face\nface_areas    : Area of of each face\nface_visibility_graph : FaceVisibilityGraph for efficient visibility queries\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.Ray","page":"Types","title":"AsteroidShapeModels.Ray","text":"Ray\n\nStructure representing a ray in 3D space.\n\nFields\n\norigin    : Ray origin point\ndirection : Ray direction vector (normalized)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.BoundingBox","page":"Types","title":"AsteroidShapeModels.BoundingBox","text":"BoundingBox\n\nStructure representing a bounding box for shape models.\n\nFields\n\nmin_point : Minimum point of the bounding box (minimum x, y, z values)\nmax_point : Maximum point of the bounding box (maximum x, y, z values)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Result-Types","page":"Types","title":"Result Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.RayTriangleIntersectionResult","page":"Types","title":"AsteroidShapeModels.RayTriangleIntersectionResult","text":"RayTriangleIntersectionResult\n\nStructure representing the result of ray-triangle intersection test.\n\nFields\n\nhit      : true if intersection exists, false otherwise\ndistance : Distance from ray origin to intersection point\npoint    : Coordinates of the intersection point\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.RayShapeIntersectionResult","page":"Types","title":"AsteroidShapeModels.RayShapeIntersectionResult","text":"RayShapeIntersectionResult\n\nStructure representing the result of ray-shape intersection test.\n\nFields\n\nhit        : true if intersection exists, false otherwise\ndistance   : Distance from ray origin to intersection point\npoint      : Coordinates of the intersection point\nface_index : Index of the intersected face\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Visibility-Types","page":"Types","title":"Visibility Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.VisibleFacet","page":"Types","title":"AsteroidShapeModels.VisibleFacet","text":"struct VisibleFacet\n\nIndex of an interfacing facet and its view factor\n\nFields\n\nid : Index of the interfacing facet\nf  : View factor from facet i to j\nd  : Distance from facet i to j\nd̂  : Normal vector from facet i to j\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.FaceVisibilityGraph","page":"Types","title":"AsteroidShapeModels.FaceVisibilityGraph","text":"FaceVisibilityGraph\n\nEfficient visible face graph structure using CSR (Compressed Sparse Row) format. Provides better memory efficiency and cache locality compared to adjacency list format.\n\nFields\n\nrow_ptr: Start index of visible face data for each face (length: nfaces + 1)\ncol_idx: Indices of visible faces (column indices in CSR format)\nview_factors: View factors for each visible face pair\ndistances: Distances between each visible face pair\ndirections: Unit direction vectors between each visible face pair\nnfaces: Total number of faces\nnnz: Number of non-zero elements (total number of visible face pairs)\n\nExample\n\nIf face 1 is visible to faces 2,3 and face 2 is visible to faces 1,3,4:\n\nrow_ptr = [1, 3, 6, 7]\ncol_idx = [2, 3, 1, 3, 4, ...]\n\n\n\n\n\n","category":"type"},{"location":"api/geometry/#Geometric-Operations","page":"Geometric Operations","title":"Geometric Operations","text":"","category":"section"},{"location":"api/geometry/#Face-Properties","page":"Geometric Operations","title":"Face Properties","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.face_center","page":"Geometric Operations","title":"AsteroidShapeModels.face_center","text":"face_center(vs::StaticVector{3, <:StaticVector{3}}) -> StaticVector{3}\nface_center(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> StaticVector{3}\n\nCalculate the center (centroid) of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle\n\nReturns\n\nStaticVector{3}: The center point of the triangle, computed as the arithmetic mean of the three vertices\n\nExamples\n\nv1 = SA[1.0, 0.0, 0.0]\nv2 = SA[0.0, 1.0, 0.0]\nv3 = SA[0.0, 0.0, 1.0]\ncenter = face_center(v1, v2, v3)  # Returns SA[1/3, 1/3, 1/3]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.face_normal","page":"Geometric Operations","title":"AsteroidShapeModels.face_normal","text":"face_normal(vs::StaticVector{3, <:StaticVector{3}}) -> StaticVector{3}\nface_normal(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> StaticVector{3}\n\nCalculate the unit normal vector of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle in counter-clockwise order\n\nReturns\n\nStaticVector{3}: The unit normal vector pointing outward from the face (following right-hand rule)\n\nNotes\n\nThe normal direction follows the right-hand rule based on the vertex ordering. For a counter-clockwise vertex ordering when viewed from outside, the normal points outward.\n\nExamples\n\nv1 = SA[1.0, 0.0, 0.0]\nv2 = SA[0.0, 1.0, 0.0]\nv3 = SA[0.0, 0.0, 0.0]\nnormal = face_normal(v1, v2, v3)  # Returns SA[0.0, 0.0, 1.0]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.face_area","page":"Geometric Operations","title":"AsteroidShapeModels.face_area","text":"face_area(vs::StaticVector{3, <:StaticVector{3}}) -> Real\nface_area(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> Real\n\nCalculate the area of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle\n\nReturns\n\nReal: The area of the triangle\n\nNotes\n\nThe area is computed using the cross product formula: area = ||(v2 - v1) × (v3 - v2)|| / 2\n\nExamples\n\n# Unit right triangle\nv1 = SA[0.0, 0.0, 0.0]\nv2 = SA[1.0, 0.0, 0.0]\nv3 = SA[0.0, 1.0, 0.0]\narea = face_area(v1, v2, v3)  # Returns 0.5\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Shape-Properties","page":"Geometric Operations","title":"Shape Properties","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.polyhedron_volume","page":"Geometric Operations","title":"AsteroidShapeModels.polyhedron_volume","text":"polyhedron_volume(nodes, faces) -> Float64\npolyhedron_volume(shape::ShapeModel) -> Float64\n\nCalculate the volume of a polyhedron using the divergence theorem.\n\nArguments\n\nnodes: Array of vertex positions\nfaces: Array of triangular face definitions (vertex indices)\nshape::ShapeModel: A shape model containing nodes and faces\n\nReturns\n\nFloat64: Volume of the polyhedron\n\nNotes\n\nThe volume is computed using the formula: V = (1/6) * Σ (A × B) · C where A, B, C are the vertices of each triangular face. The shape must be a closed polyhedron with consistently oriented faces.\n\nExamples\n\n# Unit cube\nnodes = [SA[0,0,0], SA[1,0,0], SA[1,1,0], SA[0,1,0],\n         SA[0,0,1], SA[1,0,1], SA[1,1,1], SA[0,1,1]]\nfaces = [SA[1,2,3], SA[1,3,4], ...]  # Define all 12 triangular faces\nvol = polyhedron_volume(nodes, faces)  # Returns 1.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.equivalent_radius","page":"Geometric Operations","title":"AsteroidShapeModels.equivalent_radius","text":"equivalent_radius(VOLUME::Real) -> Float64\nequivalent_radius(shape::ShapeModel) -> Float64\n\nCalculate the radius of a sphere with the same volume as the given volume or shape.\n\nArguments\n\nVOLUME::Real: Volume of the object\nshape::ShapeModel: A shape model to calculate volume from\n\nReturns\n\nFloat64: Radius of the equivalent sphere\n\nNotes\n\nThe equivalent radius is calculated as: r = (3V/4π)^(1/3)\n\nExamples\n\n# Sphere with radius 2\nvolume = 4π/3 * 2^3\nr_eq = equivalent_radius(volume)  # Returns 2.0\n\n# From shape model\nshape = load_shape_obj(\"asteroid.obj\")\nr_eq = equivalent_radius(shape)\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.maximum_radius","page":"Geometric Operations","title":"AsteroidShapeModels.maximum_radius","text":"maximum_radius(nodes) -> Float64\nmaximum_radius(shape::ShapeModel) -> Float64\n\nCalculate the maximum distance from the origin to any vertex.\n\nArguments\n\nnodes: Array of vertex positions\nshape::ShapeModel: A shape model containing nodes\n\nReturns\n\nFloat64: Maximum distance from origin to any vertex\n\nNotes\n\nThis represents the radius of the smallest sphere centered at the origin that contains all vertices of the shape.\n\nExamples\n\nnodes = [SA[1,0,0], SA[0,2,0], SA[0,0,3]]\nr_max = maximum_radius(nodes)  # Returns 3.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.minimum_radius","page":"Geometric Operations","title":"AsteroidShapeModels.minimum_radius","text":"minimum_radius(nodes) -> Float64\nminimum_radius(shape::ShapeModel) -> Float64\n\nCalculate the minimum distance from the origin to any vertex.\n\nArguments\n\nnodes: Array of vertex positions\nshape::ShapeModel: A shape model containing nodes\n\nReturns\n\nFloat64: Minimum distance from origin to any vertex\n\nNotes\n\nThis represents the radius of the largest sphere centered at the origin that fits entirely inside the convex hull of the vertices.\n\nExamples\n\nnodes = [SA[1,0,0], SA[0,2,0], SA[0,0,3]]\nr_min = minimum_radius(nodes)  # Returns 1.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Angle-Calculations","page":"Geometric Operations","title":"Angle Calculations","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.angle_rad","page":"Geometric Operations","title":"AsteroidShapeModels.angle_rad","text":"angle_rad(v1, v2) -> Float64\n\nCalculate the angle between two vectors in radians.\n\nArguments\n\nv1 : First vector\nv2 : Second vector\n\nReturns\n\nAngle between vectors in radians [0, π]\n\n\n\n\n\nangle_rad(v1::AbstractVector{<:AbstractVector}, v2::AbstractVector{<:AbstractVector}) -> Vector{Float64}\n\nCalculate angles between corresponding pairs of vectors in two arrays (broadcast version).\n\nArguments\n\nv1: Array of first vectors\nv2: Array of second vectors (must have same length as v1)\n\nReturns\n\nArray of angles in radians between corresponding vector pairs\n\nExamples\n\nv1s = [SA[1,0,0], SA[0,1,0]]\nv2s = [SA[0,1,0], SA[1,0,0]]\nangles = angle_rad(v1s, v2s)  # Returns [π/2, π/2]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.angle_deg","page":"Geometric Operations","title":"AsteroidShapeModels.angle_deg","text":"angle_deg(v1, v2) -> Float64\n\nCalculate the angle between two vectors in degrees.\n\nArguments\n\nv1 : First vector\nv2 : Second vector\n\nReturns\n\nAngle between vectors in degrees [0, 180]\n\n\n\n\n\nangle_deg(v1::AbstractVector{<:AbstractVector}, v2::AbstractVector{<:AbstractVector}) -> Vector{Float64}\n\nCalculate angles between corresponding pairs of vectors in two arrays (broadcast version).\n\nArguments\n\nv1: Array of first vectors\nv2: Array of second vectors (must have same length as v1)\n\nReturns\n\nArray of angles in degrees between corresponding vector pairs\n\nExamples\n\nv1s = [SA[1,0,0], SA[0,1,0]]\nv2s = [SA[0,1,0], SA[1,0,0]]\nangles = angle_deg(v1s, v2s)  # Returns [90.0, 90.0]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.solar_phase_angle","page":"Geometric Operations","title":"AsteroidShapeModels.solar_phase_angle","text":"solar_phase_angle(sun, target, observer) -> Float64\n\nCalculate a sun-target-observer angle (phase angle).\n\nArguments\n\nsun      : Sun position vector\ntarget   : Target position vector\nobserver : Observer position vector\n\nReturns\n\n∠STO : Sun-target-observer angle (phase angle) [rad]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.solar_elongation_angle","page":"Geometric Operations","title":"AsteroidShapeModels.solar_elongation_angle","text":"solar_elongation_angle(sun, observer, target) -> Float64\n\nCalculate a sun-observer-target angle (solar elongation angle).\n\nArguments\n\nsun      : Sun position vector\nobserver : Observer position vector\ntarget   : Target position vector\n\nReturns\n\n∠SOT : Sun-observer-target angle (solar elongation angle) [rad]\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#Ray-Intersection","page":"Ray Intersection","title":"Ray Intersection","text":"","category":"section"},{"location":"api/raycast/#High-Level-Functions","page":"Ray Intersection","title":"High-Level Functions","text":"","category":"section"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_shape","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_shape","text":"intersect_ray_shape(ray::Ray, shape::ShapeModel, bbox::BoundingBox) -> RayShapeIntersectionResult\n\nPerform accelerated ray-shape intersection test using bounding box optimization. Uses the Möller–Trumbore algorithm for ray-triangle mesh intersection.\n\nArguments\n\nray: Ray\nshape: Shape model\nbbox: Bounding box of the shape model\n\nReturns\n\nRayShapeIntersectionResult object containing the intersection test result\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#Low-Level-Functions","page":"Ray Intersection","title":"Low-Level Functions","text":"","category":"section"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_triangle","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_triangle","text":"intersect_ray_triangle(ray::Ray, v1::AbstractVector{<:Real}, v2::AbstractVector{<:Real}, v3::AbstractVector{<:Real}) -> RayTriangleIntersectionResult\n\nPerform ray-triangle intersection test using the Möller–Trumbore algorithm.\n\nArguments\n\nray: Ray\nv1: Triangle vertex 1\nv2: Triangle vertex 2\nv3: Triangle vertex 3\n\nReturns\n\nRayTriangleIntersectionResult object containing the intersection test result\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_bounding_box","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_bounding_box","text":"intersect_ray_bounding_box(ray::Ray, bbox::BoundingBox) -> Bool\n\nPerform intersection test between a ray and a bounding box.\n\nArguments\n\nray: Ray\nbbox: Bounding box\n\nReturns\n\ntrue if intersection occurs, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#AsteroidShapeModels.compute_bounding_box","page":"Ray Intersection","title":"AsteroidShapeModels.compute_bounding_box","text":"compute_bounding_box(shape::ShapeModel) -> BoundingBox\n\nCompute the bounding box of a shape model.\n\nArguments\n\nshape: Shape model\n\nReturns\n\nBoundingBox object representing the bounding box\n\n\n\n\n\n","category":"function"},{"location":"api/roughness/#Surface-Roughness","page":"Surface Roughness","title":"Surface Roughness","text":"","category":"section"},{"location":"api/roughness/#Crater-Modeling","page":"Surface Roughness","title":"Crater Modeling","text":"","category":"section"},{"location":"api/roughness/#AsteroidShapeModels.crater_curvature_radius","page":"Surface Roughness","title":"AsteroidShapeModels.crater_curvature_radius","text":"crater_curvature_radius(r, h) -> R\n\nReturn the curvature radius of a concave spherical segment.\n\nArguments\n\nr: Crater radius\nh: Crater depth\n\n\n\n\n\n","category":"function"},{"location":"api/roughness/#AsteroidShapeModels.concave_spherical_segment","page":"Surface Roughness","title":"AsteroidShapeModels.concave_spherical_segment","text":"concave_spherical_segment(r, h, xc, yc, x, y) -> z\n\nReturn the z-coordinate of a concave spherical segment.\n\nArguments\n\nr : Crater radius\nh : Crater depth\nxc: x-coordinate of crater center\nyc: y-coordinate of crater center\nx : x-coordinate where to calculate z\ny : y-coordinate where to calculate z\n\n\n\n\n\nconcave_spherical_segment(r, h; Nx=2^5, Ny=2^5, xc=0.5, yc=0.5) -> xs, ys, zs\n\nReturn (x, y, z) grid of a concave spherical segment.\n\nArguments\n\nr : Crater radius\nh : Crater depth\nNx: Number of nodes in the x-direction\nNy: Number of nodes in the y-direction\nxc: x-coordinate of crater center\nyc: y-coordinate of crater center\n\n\n\n\n\n","category":"function"},{"location":"#AsteroidShapeModels.jl","page":"Home","title":"AsteroidShapeModels.jl","text":"","category":"section"},{"location":"#AsteroidShapeModels.AsteroidShapeModels","page":"Home","title":"AsteroidShapeModels.AsteroidShapeModels","text":"AsteroidShapeModels\n\nA Julia package for geometric processing and analysis of asteroid shape models.\n\nThis package provides comprehensive tools for working with polyhedral shape models of asteroids, including loading from OBJ files, computing geometric properties, ray-shape intersection, visibility analysis, and surface roughness modeling.\n\nMain Types\n\nShapeModel: Core data structure for polyhedral shapes\nRay, BoundingBox: Ray casting and acceleration structures\nFaceVisibilityGraph: CSR-style data structure for face-to-face visibility\n\nKey Functions\n\nShape I/O: load_shape_obj, loadobj, load_shape_grid\nGeometric properties: face_center, face_normal, face_area, polyhedron_volume\nRay intersection: intersect_ray_triangle, intersect_ray_shape\nVisibility: build_face_visibility_graph!, isilluminated, view_factor\nShape analysis: equivalent_radius, maximum_radius, minimum_radius\n\nExample\n\nusing AsteroidShapeModels\n\n# Load an asteroid shape model with face-face visibility\nshape = load_shape_obj(\"path/to/shape.obj\", scale=1000, with_face_visibility=true)  # Convert km to m\n\n# Access to face properties\nshape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face\n\nSee the documentation for detailed usage examples and API reference.\n\n\n\n\n\n","category":"module"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AsteroidShapeModels.jl provides comprehensive tools for working with polyhedral shape models of asteroids. The package supports:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loading shape models from OBJ files\nComputing geometric properties (area, volume, normals)\nRay-shape intersection testing\nFace-to-face visibility analysis\nSurface roughness modeling\nIllumination calculations","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AsteroidShapeModels\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AsteroidShapeModels\n\n# Load an asteroid shape model with face-face visibility\nshape = load_shape_obj(\"path/to/shape.obj\", scale=1000, with_face_visibility=true)  # Convert km to m\n\n# Access to face properties\nshape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Shape-Model-Management","page":"Home","title":"Shape Model Management","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load polyhedral models from OBJ files\nAutomatic computation of face centers, normals, and areas\nSupport for scaling and coordinate transformations","category":"page"},{"location":"#Geometric-Analysis","page":"Home","title":"Geometric Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Face properties: center, normal, area\nShape properties: volume, equivalent radius\nBounding box computation","category":"page"},{"location":"#Ray-Intersection","page":"Home","title":"Ray Intersection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast ray-triangle intersection\nRay-shape intersection\nBounding box acceleration","category":"page"},{"location":"#Visibility-Analysis","page":"Home","title":"Visibility Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Face-to-face visibility computation\nView factor calculations\nIllumination determination","category":"page"},{"location":"#Surface-Roughness","page":"Home","title":"Surface Roughness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Crater modeling\nSurface curvature analysis","category":"page"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"types.jl - Core data structures and type definitions\nobj_io.jl - OBJ file loading and parsing\nface_properties.jl - Face geometric computations (center, normal, area)\nshape_operations.jl - Shape-level operations (volume, radius calculations)\nray_intersection.jl - Ray casting and intersection algorithms\nvisibility.jl - Face-to-face visibility and illumination analysis\ngeometry_utils.jl - Geometric helper functions and angle calculations\nroughness.jl - Surface roughness and crater modeling","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates the main features of AsteroidShapeModels.jl through practical examples.","category":"page"},{"location":"tutorial/#Loading-a-Shape-Model","page":"Tutorial","title":"Loading a Shape Model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using AsteroidShapeModels\nusing StaticArrays\n\n# Load from OBJ file\nshape = load_shape_obj(\"asteroid.obj\")\n\n# Load with scaling (e.g., converting km to m)\nshape_m = load_shape_obj(\"asteroid.obj\", scale=1000)\n\n# Access shape properties\nprintln(\"Number of vertices: \", length(shape.vertices))\nprintln(\"Number of faces: \", length(shape.faces))\nprintln(\"Number of edges: \", length(shape.edges))","category":"page"},{"location":"tutorial/#Working-with-Face-Properties","page":"Tutorial","title":"Working with Face Properties","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"shape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face\n\n# Get properties of face 1\nshape.face_centers[1]  # Center position of each face\nshape.face_normals[1]  # Normal vector of each face\nshape.face_areas[1]    # Area of of each face","category":"page"},{"location":"tutorial/#Shape-Analysis","page":"Tutorial","title":"Shape Analysis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Compute shape properties\nvolume = polyhedron_volume(shape)\neq_radius = equivalent_radius(shape)\nmax_radius = maximum_radius(shape)\nmin_radius = minimum_radius(shape)\n\nprintln(\"Volume: \", volume, \" m³\")\nprintln(\"Equivalent radius: \", eq_radius, \" m\")\nprintln(\"Maximum radius: \", max_radius, \" m\")\nprintln(\"Minimum radius: \", min_radius, \" m\")\nprintln(\"Axis ratio (max/min): \", max_radius / min_radius)\n\n# Compute bounding box\nbbox = compute_bounding_box(shape)","category":"page"},{"location":"tutorial/#Performance-Tips","page":"Tutorial","title":"Performance Tips","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use StaticArrays: All vector operations use SVector for performance\nBatch operations: Process multiple rays or faces together\nScale appropriately: Use consistent units (typically meters)","category":"page"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See the API Reference pages for detailed function documentation\nCheck the test suite for more examples\nExplore integration with SPICE.jl for ephemeris data","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#FaceVisibilityGraph-Performance-Benchmark-Results-(v0.2.0)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"This document records the performance comparison between the legacy adjacency list implementation and the new CSR-style FaceVisibilityGraph implementation introduced in PR #12.","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Test-Environment","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Test Environment","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Date: December 2024\nJulia Version: 1.11.5\nMachine: Apple M1/M2 (specify your machine)\nCommit: cae08e7 (feature/face-visibility-graph)","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Benchmark-Results","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Benchmark Results","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#1.-Small-Model-(Ryugu-test-shape-5,932-faces)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"1. Small Model (Ryugu test shape - 5,932 faces)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Visibility-Computation-Time","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Visibility Computation Time","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy implementation: 391.08 ms\nFaceVisibilityGraph:   97.51 ms\nSpeed up: 4.01x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Memory-Usage","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy (adjacency list): 11.7 MB\nFaceVisibilityGraph:     5.9 MB\nMemory reduction: 49.6%","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#2.-Large-Model-(Ryugu-49k-49,152-faces)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"2. Large Model (Ryugu 49k - 49,152 faces)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Visibility-Computation-Time-2","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Visibility Computation Time","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy implementation: 29.064 seconds\nFaceVisibilityGraph:   28.778 seconds\nSpeed up: 1.01x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Memory-Usage-2","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy (adjacency list): 561.92 MB\nFaceVisibilityGraph:     281.34 MB\nMemory reduction: 49.9%","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Query-Performance-(isilluminated-1000-queries)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Query Performance (isilluminated - 1000 queries)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy implementation: 52.88 μs\nFaceVisibilityGraph:   49.67 μs\nSpeed ratio: 1.06x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Verification-of-Results","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Verification of Results","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Computation-Results-Match","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Computation Results Match","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"All tests confirm that both implementations produce identical results:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"✅ Same number of visible face pairs\n✅ Same view factors (floating point equality)\n✅ Same distances\n✅ Same direction vectors\n✅ Same isilluminated results","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Test-Code-for-Verification","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Test Code for Verification","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"# From test/test_face_visibility_graph.jl\n@testset \"Legacy vs New Implementation\" begin\n    shape_legacy = ShapeModel(nodes, faces)\n    find_visiblefacets!(shape_legacy, use_visibility_graph=false)\n    \n    shape_new = ShapeModel(nodes, faces)\n    find_visiblefacets!(shape_new, use_visibility_graph=true)\n    \n    for i in 1:length(faces)\n        @test length(legacy_visible) == length(new_visible)\n        @test sort(legacy_ids) == sort(new_ids)\n        # View factors, distances, and directions also match\n    end\nend","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Key-Findings","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Key Findings","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Small models (< 10k faces): Significant speedup (4x) due to reduced overhead\nLarge models (> 40k faces): Similar computation time, but 50% memory savings\nConsistent memory reduction: ~50% across all model sizes\nCache efficiency: Better sequential access patterns with CSR format","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Reproducing-These-Benchmarks","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Reproducing These Benchmarks","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"To reproduce these benchmarks on future versions:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"# Checkout the commit before FaceVisibilityGraph\ngit checkout e3529d2\n\n# Run legacy benchmark\njulia --project=. benchmark/compare_visibility.jl\n\n# Checkout the commit with FaceVisibilityGraph\ngit checkout feature/face-visibility-graph\n\n# Run comparison benchmark\njulia --project=. benchmark/compare_visibility.jl\njulia --project=. benchmark/benchmark_49k_shape.jl","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Migration-Notes","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Migration Notes","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"When removing backward compatibility in v0.3.0:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"The use_visibility_graph parameter will be removed\nOnly FaceVisibilityGraph will be used\nThese benchmark results serve as the baseline for future optimizations","category":"page"}]
}
