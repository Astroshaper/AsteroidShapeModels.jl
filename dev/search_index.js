var documenterSearchIndex = {"docs":
[{"location":"api/raycast/#Ray-Intersection","page":"Ray Intersection","title":"Ray Intersection","text":"","category":"section"},{"location":"api/raycast/#High-Level-Functions","page":"Ray Intersection","title":"High-Level Functions","text":"","category":"section"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_shape","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_shape","text":"intersect_ray_shape(shape::ShapeModel, origins::AbstractMatrix{<:Real}, directions::AbstractMatrix{<:Real}) -> Vector{RayShapeIntersectionResult}\n\nPerform batch ray-shape intersection tests using the same interface as ImplicitBVH.traverse_rays.\n\nThis is the core implementation that all other intersect_ray_shape methods delegate to.\n\nnote: Note\nAs of v0.4.0, BVH must be pre-built before calling this function. Use either with_bvh=true when loading or call build_bvh!(shape) explicitly.\n\nArguments\n\nshape      : Shape model (must have BVH built via build_bvh!)\norigins    : 3×N matrix where each column is a ray origin\ndirections : 3×N matrix where each column is a ray direction\n\nReturns\n\nVector of RayShapeIntersectionResult objects, one for each input ray\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nNotes\n\nThis function provides a convenient interface that matches ImplicitBVH.traverse_rays parameters\nBVH must be pre-built using build_bvh!(shape) or by creating the shape with with_bvh=true\nAll rays are processed in a single batch for efficiency\n\nExample\n\n# Create ray data\nn_rays = 100\norigins = rand(3, n_rays) .* 1000  # Random origins\ndirections = normalize.(eachcol(rand(3, n_rays) .- 0.5))  # Random directions\n\n# Convert directions back to matrix\ndirections = hcat(directions...)\n\n# Perform batch intersection\nresults = intersect_ray_shape(shape, origins, directions)\n\n\n\n\n\nintersect_ray_shape(ray::Ray, shape::ShapeModel) -> RayShapeIntersectionResult\n\nPerform ray-shape intersection test using BVH acceleration. Uses the Möller–Trumbore algorithm for ray-triangle mesh intersection.\n\nnote: Note\nAs of v0.4.0, BVH must be pre-built before calling this function. Use either with_bvh=true when loading or call build_bvh!(shape) explicitly.\n\nArguments\n\nray   : Ray with origin and direction\nshape : Shape model (must have BVH built via build_bvh!)\n\nReturns\n\nRayShapeIntersectionResult object containing the intersection test result\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nNotes\n\nBVH must be pre-built using build_bvh!(shape) or by creating the shape with with_bvh=true\nTo pre-build BVH, use load_shape_obj(\"path/to/shape.obj\"; with_bvh=true)\nOr for an existing ShapeModel: build_bvh!(shape)\n\nExample\n\nray = Ray(SA[0.0, 0.0, 1000.0], SA[0.0, 0.0, -1.0])\nresult = intersect_ray_shape(ray, shape)\n\nif result.hit\n    println(\"Hit face $(result.face_idx) at distance $(result.distance)\")\nend\n\n\n\n\n\nintersect_ray_shape(rays::AbstractVector{Ray}, shape::ShapeModel) -> Vector{RayShapeIntersectionResult}\n\nPerform batch ray-shape intersection tests for multiple rays.\n\nnote: Note\nAs of v0.4.0, BVH must be pre-built before calling this function. Use either with_bvh=true when loading or call build_bvh!(shape) explicitly.\n\nArguments\n\nrays  : Vector of Ray objects\nshape : Shape model (must have BVH built via build_bvh!)\n\nReturns\n\nVector of RayShapeIntersectionResult objects, one for each input ray\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nExample\n\n# Create a vector of rays\nrays = [Ray(SA[x, 0.0, 1000.0], SA[0.0, 0.0, -1.0]) for x in -500:100:500]\nresults = intersect_ray_shape(rays, shape)\n\n# Count hits\nn_hits = count(r -> r.hit, results)\nprintln(\"$n_hits out of $(length(rays)) rays hit the shape\")\n\n\n\n\n\nintersect_ray_shape(rays::AbstractMatrix{Ray}, shape::ShapeModel) -> Matrix{RayShapeIntersectionResult}\n\nPerform batch ray-shape intersection tests for a matrix of rays. The output shape matches the input shape, preserving spatial arrangement.\n\nnote: Note\nAs of v0.4.0, BVH must be pre-built before calling this function. Use either with_bvh=true when loading or call build_bvh!(shape) explicitly.\n\nArguments\n\nrays  : Matrix of Ray objects\nshape : Shape model (must have BVH built via build_bvh!)\n\nReturns\n\nMatrix of RayShapeIntersectionResult objects with the same size as input\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nExample\n\n# Create a matrix of rays\nrays = [Ray(SA[x, y, 1000.0], SA[0.0, 0.0, -1.0]) for x in -500:100:500, y in -500:100:500]\nresults = intersect_ray_shape(rays, shape)\n\n# Process results while preserving grid structure\nfor i in 1:size(results, 1), j in 1:size(results, 2)\n    if results[i, j].hit\n        println(\"Ray at ($i, $j) hit at $(results[i, j].point)\")\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#Low-Level-Functions","page":"Ray Intersection","title":"Low-Level Functions","text":"","category":"section"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_triangle","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_triangle","text":"intersect_ray_triangle(ray::Ray, v1::AbstractVector{<:Real}, v2::AbstractVector{<:Real}, v3::AbstractVector{<:Real}) -> RayTriangleIntersectionResult\n\nPerform ray-triangle intersection test using the Möller–Trumbore algorithm.\n\nArguments\n\nray: Ray with origin and direction\nv1: Triangle vertex 1\nv2: Triangle vertex 2\nv3: Triangle vertex 3\n\nReturns\n\nRayTriangleIntersectionResult object containing the intersection test result\n\nAlgorithm Details\n\nThis implementation has the following characteristics:\n\nNo backface culling: Triangles are hit from both sides (front and back)\nForward rays only: Only intersections in the ray direction are detected (distance > 0)\nNo self-intersection: Rays starting exactly on the triangle surface typically miss due to numerical precision\n\nExample\n\n# Ray from above hits triangle on XY plane\nray = Ray(SA[0.5, 0.5, 1.0], SA[0.0, 0.0, -1.0])\nv1, v2, v3 = SA[0.0, 0.0, 0.0], SA[1.0, 0.0, 0.0], SA[0.0, 1.0, 0.0]\nresult = intersect_ray_triangle(ray, v1, v2, v3)\n# result.hit == true, result.distance ≈ 1.0\n\n# Ray from below also hits (no backface culling)\nray_below = Ray(SA[0.5, 0.5, -1.0], SA[0.0, 0.0, 1.0])\nresult = intersect_ray_triangle(ray_below, v1, v2, v3)\n# result.hit == true\n\n# Ray pointing away misses (backward intersection rejected)\nray_away = Ray(SA[0.5, 0.5, 1.0], SA[0.0, 0.0, 1.0])\nresult = intersect_ray_triangle(ray_away, v1, v2, v3)\n# result.hit == false\n\n\n\n\n\nintersect_ray_triangle(ray::Ray, shape::ShapeModel, face_idx::Integer) -> RayTriangleIntersectionResult\n\nPerform ray-triangle intersection test for a specific face in a shape model.\n\nArguments\n\nray      : Ray with origin and direction\nshape    : Shape model containing the triangle\nface_idx : Index of the face to test (1-based)\n\nReturns\n\nRayTriangleIntersectionResult object containing the intersection test result\n\nAlgorithm Details\n\nThis function uses the same Möller-Trumbore algorithm as the base implementation:\n\nNo backface culling (triangles are hit from both sides)\nForward rays only (distance > 0)\nInlined for performance\n\nExample\n\nshape = load_shape_obj(\"asteroid.obj\")\nray = Ray(SA[0.0, 0.0, 100.0], SA[0.0, 0.0, -1.0])\nresult = intersect_ray_triangle(ray, shape, 1)  # Test first face\n\n\n\n\n\nintersect_ray_triangle(ray::Ray, nodes::AbstractVector, faces::AbstractVector, face_idx::Integer) -> RayTriangleIntersectionResult\n\nPerform ray-triangle intersection test for a specific face given nodes and faces arrays.\n\nArguments\n\nray      : Ray with origin and direction\nnodes    : Array of node positions (3D vectors)\nfaces    : Array of face definitions (each face is an array of 3 node indices)\nface_idx : Index of the face to test (1-based)\n\nReturns\n\nRayTriangleIntersectionResult object containing the intersection test result\n\nAlgorithm Details\n\nThis function uses the same Möller-Trumbore algorithm as the base implementation:\n\nNo backface culling (triangles are hit from both sides)\nForward rays only (distance > 0)\nInlined for performance\n\nNotes\n\nThis is a lower-level interface useful when working directly with node and face arrays without a full ShapeModel structure.\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_sphere","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_sphere","text":"intersect_ray_sphere(\n    ray_origin::SVector{3, Float64}, ray_direction::SVector{3, Float64}, \n    sphere_center::SVector{3, Float64}, sphere_radius::Float64,\n) -> RaySphereIntersectionResult\n\nTest if a ray intersects with a sphere.\n\nArguments\n\nray_origin    : Starting point of the ray\nray_direction : Direction of the ray (will be normalized internally)\nsphere_center : Center of the sphere\nsphere_radius : Radius of the sphere\n\nReturns\n\nRaySphereIntersectionResult with fields:\n\nhit::Bool                   : true if the ray intersects the sphere\ndistance1::Float64          : Distance to first intersection point (NaN if no intersection)\ndistance2::Float64          : Distance to second intersection point (NaN if no intersection)\npoint1::SVector{3, Float64} : First intersection point coordinates\npoint2::SVector{3, Float64} : Second intersection point coordinates\n\nSpecial Cases\n\nRay origin inside sphere: When the ray starts inside the sphere, distance1 < 0 (behind the origin)  and distance2 > 0 (in front of the origin). The ray will always hit the sphere from inside.\nRay origin on sphere surface: When the ray starts exactly on the sphere surface, distance1 ≈ 0.\nTangent ray: When the ray just touches the sphere, distance1 ≈ distance2.\nSphere behind ray: When both intersection points are behind the ray origin (distance2 < 0),  the function returns no intersection as the sphere is not in the ray's forward direction.\nDegenerate cases: Returns no intersection for zero or negative radius spheres, or zero-length ray directions.\n\nAlgorithm\n\nSolves the quadratic equation for ray-sphere intersection: |rayorigin + t * raydirection - spherecenter|² = sphereradius²\n\nExample\n\nray_origin    = SVector(0.0, 0.0, 0.0)\nray_direction = SVector(1.0, 0.0, 0.0)  # Normalization is handled internally\nsphere_center = SVector(5.0, 0.0, 0.0)\nsphere_radius = 2.0\n\nresult = intersect_ray_sphere(ray_origin, ray_direction, sphere_center, sphere_radius)\nif result.hit\n    println(\"Ray hits sphere at distances: \", result.distance1, \" and \", result.distance2)\n    println(\"Entry point : \", result.point1)\n    println(\"Exit point  : \", result.point2)\nend\n\n\n\n\n\nintersect_ray_sphere(ray::Ray, sphere::Sphere) -> RaySphereIntersectionResult\n\nTest if a ray intersects with a sphere using Ray and Sphere objects.\n\nThis is a convenience overload that extracts the parameters from the Ray and Sphere  objects and calls the main implementation.\n\nArguments\n\nray    : Ray object containing origin and direction\nsphere : Sphere object containing center and radius\n\nReturns\n\nRaySphereIntersectionResult with intersection details\n\nExample\n\nray = Ray([0.0, 0.0, 0.0], [1.0, 0.0, 0.0])\nsphere = Sphere([5.0, 0.0, 0.0], 2.0)\n\nresult = intersect_ray_sphere(ray, sphere)\nif result.hit\n    println(\"Ray hits sphere at distances: \", result.distance1, \" and \", result.distance2)\n    println(\"Entry point : \", result.point1)\n    println(\"Exit point  : \", result.point2)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#Visibility-Analysis","page":"Visibility Analysis","title":"Visibility Analysis","text":"","category":"section"},{"location":"api/visibility/#Main-Functions","page":"Visibility Analysis","title":"Main Functions","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.build_face_visibility_graph!","page":"Visibility Analysis","title":"AsteroidShapeModels.build_face_visibility_graph!","text":"build_face_visibility_graph!(shape::ShapeModel)\n\nBuild face-to-face visibility graph for the shape model.\n\nThis function computes which faces are visible from each face and stores the results in a FaceVisibilityGraph structure using CSR (Compressed Sparse Row) format.\n\nArguments\n\nshape : Shape model of an asteroid\n\nAlgorithm\n\nThe implementation uses an optimized non-BVH algorithm with candidate filtering:\n\nPre-filter candidate faces based on normal orientations\nSort candidates by distance for efficient occlusion testing\nCheck visibility between face pairs using ray-triangle intersection\nStore results in memory-efficient CSR format\n\nPerformance Considerations\n\nBVH acceleration was found to be less efficient for face visibility pair searches compared to the optimized candidate filtering approach (slower ~0.5x)\nThe non-BVH implementation with distance-based sorting provides better performance due to the specific nature of face-to-face visibility queries\nDistance-based sorting provides ~2x speedup over naive approaches\n\nNotes\n\nThe visibility graph is stored in shape.face_visibility_graph\nThis is a computationally intensive operation, especially for large models\nThe resulting graph contains view factors, distances, and direction vectors\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.compute_face_max_elevations!","page":"Visibility Analysis","title":"AsteroidShapeModels.compute_face_max_elevations!","text":"compute_face_max_elevations!(shape::ShapeModel)\n\nCompute the maximum elevation angle for each face based on the face visibility graph.\n\nDescription\n\nFor each face, this function calculates the maximum elevation angle from which the face can potentially be shadowed by any visible face. If the sun's elevation is higher than this angle, the face is guaranteed to be illuminated (if facing the sun).\n\nThe elevation is calculated as the angle between the horizon plane (perpendicular to the face normal) and the direction to the highest visible face.\n\nArguments\n\nshape: ShapeModel with facevisibilitygraph already built\n\nReturns\n\nNothing (modifies shape.face_max_elevations in-place)\n\nAlgorithm\n\nFor each face i:\n\nGet all faces j visible from face i (from shape.face_visibility_graph)\nFor each visible face j:\nCheck maximum elevation angles on all three edges using compute_edge_max_elevation\nNote: compute_edge_max_elevation handles both edge interiors and endpoints (vertices)\nStore the maximum elevation angle found\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.view_factor","page":"Visibility Analysis","title":"AsteroidShapeModels.view_factor","text":"view_factor(cᵢ, cⱼ, n̂ᵢ, n̂ⱼ, aⱼ) -> fᵢⱼ, dᵢⱼ, d̂ᵢⱼ\n\nCalculate the view factor from face i to face j, assuming Lambertian emission.\n\nArguments\n\ncᵢ::StaticVector{3}: Center position of face i\ncⱼ::StaticVector{3}: Center position of face j\nn̂ᵢ::StaticVector{3}: Unit normal vector of face i\nn̂ⱼ::StaticVector{3}: Unit normal vector of face j\naⱼ::Real           : Area of face j\n\nReturns\n\nfᵢⱼ::Real: View factor from face i to face j\ndᵢⱼ::Real: Distance between face centers\nd̂ᵢⱼ::StaticVector{3}: Unit direction vector from face i to face j\n\nNotes\n\nThe view factor is calculated using the formula:\n\nfᵢⱼ = (cosθᵢ * cosθⱼ) / (π * dᵢⱼ²) * aⱼ\n\nwhere θᵢ and θⱼ are the angles between the line connecting the faces and the respective normal vectors.\n\nThe view factor is automatically zero when:\n\nFace i is facing away from face j (cosθᵢ ≤ 0)\nFace j is facing away from face i (cosθⱼ ≤ 0)\nBoth conditions ensure that only mutually visible faces have non-zero view factors\n\nVisual representation\n\n(i)   fᵢⱼ   (j)\n △    -->    △\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#Illumination-Analysis","page":"Visibility Analysis","title":"Illumination Analysis","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.isilluminated","page":"Visibility Analysis","title":"AsteroidShapeModels.isilluminated","text":"isilluminated(\n    shape::ShapeModel, r☉::StaticVector{3}, face_idx::Integer; \n    with_self_shadowing::Bool, use_elevation_optimization::Bool=true,\n) -> Bool\n\nCheck if a face is illuminated by the sun.\n\nArguments\n\nshape    : Shape model of an asteroid\nr☉       : Sun's position in the asteroid-fixed frame\nface_idx : Index of the face to be checked\n\nKeyword Arguments\n\nwith_self_shadowing::Bool : Whether to include self-shadowing effects.\nfalse: Use pseudo-convex model (face orientation only)\ntrue: Include self-shadowing (requires face_visibility_graph and face_max_elevations)\nuse_elevation_optimization::Bool : Whether to use elevation-based early-out optimization (default: true).\nOnly applies when with_self_shadowing=true\n\nReturns\n\ntrue if the face is illuminated\nfalse if the face is in shadow or facing away from the sun\n\nPerformance\n\nPseudo-convex model: O(1) - single dot product\nWith self-shadowing: O(n) worst case, but typically much faster due to:\nEarly-out optimization using face orientation check\nVisibility graph limits checks to potentially occluding faces only\n\nExamples\n\n# Without self-shadowing (pseudo-convex model)\nilluminated = isilluminated(shape, sun_position, face_idx; with_self_shadowing=false)\n\n# With self-shadowing (requires face_visibility_graph)\nilluminated = isilluminated(shape, sun_position, face_idx; with_self_shadowing=true)\n\nSee also: update_illumination! for batch processing\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.update_illumination!","page":"Visibility Analysis","title":"AsteroidShapeModels.update_illumination!","text":"update_illumination!(\n    illuminated_faces::AbstractVector{Bool}, shape::ShapeModel, r☉::StaticVector{3}; \n    with_self_shadowing::Bool, use_elevation_optimization::Bool=true,\n)\n\nUpdate illumination state for all faces of a shape model.\n\nArguments\n\nilluminated_faces : Boolean vector to store illumination state (must have length equal to number of faces)\nshape             : Shape model of an asteroid\nr☉                : Sun's position in the asteroid-fixed frame\n\nKeyword Arguments\n\nwith_self_shadowing::Bool : Whether to include self-shadowing effects.\nfalse: Use pseudo-convex model (face orientation only)\ntrue: Include self-shadowing (requires face_visibility_graph and face_max_elevations)\nuse_elevation_optimization::Bool : Whether to use elevation-based early-out optimization (default: true).\nOnly applies when with_self_shadowing=true\n\nPerformance\n\nPseudo-convex model: O(n) where n is number of faces\nWith self-shadowing: O(n²) worst case, but typically O(n·k) where k is average visible faces per face\n\nExamples\n\n# Prepare illumination vector\nilluminated_faces = Vector{Bool}(undef, length(shape.faces))\n\n# Without self-shadowing (pseudo-convex model)\nupdate_illumination!(illuminated_faces, shape, sun_position; with_self_shadowing=false)\n\n# With self-shadowing\nupdate_illumination!(illuminated_faces, shape, sun_position; with_self_shadowing=true)\n\nSee also: isilluminated for single face checks, apply_eclipse_shadowing! for binary asteroid shadowing\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.apply_eclipse_shadowing!","page":"Visibility Analysis","title":"AsteroidShapeModels.apply_eclipse_shadowing!","text":"apply_eclipse_shadowing!(\n    illuminated_faces::AbstractVector{Bool}, shape1::ShapeModel, r☉₁::StaticVector{3}, \n    R₁₂::StaticMatrix{3,3}, t₁₂::StaticVector{3}, shape2::ShapeModel\n) -> EclipseStatus\n\nApply eclipse shadowing effects from another shape onto already illuminated faces.\n\nwarning: Deprecated\nThis function signature will be removed in v0.5.0. Please use the new signature: apply_eclipse_shadowing!(illuminated_faces, shape1, shape2, r☉₁, r₁₂, R₁₂) which directly accepts shape2's position instead of the transformation parameter.\n\nnote: Note\nAs of v0.4.0, shape2 must have BVH pre-built before calling this function. Use either with_bvh=true when loading or call build_bvh!(shape2) explicitly.\n\nArguments\n\nilluminated_faces : Boolean vector with current illumination state (will be modified)\nshape1            : Target shape model being shadowed (the shape receiving shadows)\nr☉₁               : Sun's position in shape1's frame\nR₁₂               : 3×3 rotation matrix from shape1 frame to shape2 frame\nt₁₂               : 3D translation vector from shape1 frame to shape2 frame\nshape2            : Occluding shape model that may cast shadows on shape1 (must have BVH built via build_bvh!)\n\nReturns\n\nNO_ECLIPSE: No eclipse occurs (bodies are misaligned).\nPARTIAL_ECLIPSE: Some faces that were illuminated are now in shadow by the occluding body.\nTOTAL_ECLIPSE: All faces that were illuminated are now in shadow.\n\nThrows\n\nArgumentError if shape2 does not have BVH built. Call build_bvh!(shape2) before using this function.\n\nDescription\n\nThis function ONLY checks for mutual shadowing (eclipse) effects. It assumes that the illuminated_faces vector already contains the result of face orientation and/or self-shadowing checks. Only faces marked as true in the input will be tested for occlusion by the other body.\n\nThis separation allows flexible control of shadowing effects in thermal modeling:\n\nCall update_illumination_* first for self-shadowing (or face orientation only)\nThen call this function to add mutual shadowing effects\n\nPerformance Optimizations\n\nThe function includes early-out checks at two levels:\n\nBody-level optimizations:\n\nBehind Check: If the occluding body is entirely behind the target relative to the sun, no eclipse can occur.\nLateral Separation Check: If bodies are too far apart laterally (perpendicular to  sun direction), no eclipse can occur.\nTotal Eclipse Check: If the target is completely within the occluding body's shadow, all illuminated faces are set to false without individual ray checks.\n\nFace-level optimizations:\n\nRay-Sphere Intersection Check: For each face, checks if the ray to the sun can possibly intersect the occluding body's bounding sphere. Skips ray-shape test if the ray clearly misses the sphere.\nInscribed Sphere Check: If the ray passes through the occluding body's inscribed sphere, the face is guaranteed to be shadowed, avoiding the expensive ray-shape intersection test.\n\nThese optimizations use maximum_radius and minimum_radius for accurate sphere calculations.\n\nCoordinate Systems\n\nThe transformation from shape1 frame to shape2 frame is given by: p_shape2 = R₁₂ * p_shape1 + t₁₂\n\nExample\n\n# Check self-shadowing first\nupdate_illumination!(illuminated_faces1, shape1, sun_position1; with_self_shadowing=true)\nupdate_illumination!(illuminated_faces2, shape2, sun_position2; with_self_shadowing=true)\n\n# Or if you want to ignore self-shadowing:\nupdate_illumination!(illuminated_faces1, shape1, sun_position1; with_self_shadowing=false)\nupdate_illumination!(illuminated_faces2, shape2, sun_position2; with_self_shadowing=false)\n\n# Then check eclipse shadowing\n# For checking mutual shadowing, apply to both shape1 and shape2:\nstatus1 = apply_eclipse_shadowing!(illuminated_faces1, shape1, sun_position1, R12, t12, shape2)\nstatus2 = apply_eclipse_shadowing!(illuminated_faces2, shape2, sun_position2, R21, t21, shape1)\n\n# Handle eclipse status\nif status1 == NO_ECLIPSE\n    println(\"Shape1 is not eclipsed by shape2.\")\nelseif status1 == PARTIAL_ECLIPSE\n    println(\"Shape1 is partially eclipsed by shape2.\")\nelseif status1 == TOTAL_ECLIPSE\n    println(\"Shape1 is totally eclipsed by shape2.\")\nend\n\n\n\n\n\napply_eclipse_shadowing!(\n    illuminated_faces::AbstractVector{Bool}, shape1::ShapeModel, shape2::ShapeModel,\n    r☉₁::StaticVector{3}, r₁₂::StaticVector{3}, R₁₂::StaticMatrix{3,3}\n) -> EclipseStatus\n\nApply eclipse shadowing effects from shape2 onto shape1's already illuminated faces.\n\nThis is the recommended API as of v0.4.1, with more intuitive parameter ordering and direct use of shape2's position.\n\nnote: Note\nAs of v0.4.0, shape2 must have BVH pre-built before calling this function. Use either with_bvh=true when loading or call build_bvh!(shape2) explicitly.\n\ntip: New in v0.4.1\nThis function signature directly accepts r₁₂ (shape2's position in shape1's frame), which is more intuitive when working with SPICE data. The older signature using t₁₂ is maintained for backward compatibility but will be removed in v0.5.0.\n\nwarning: OPTIMIZE\nCurrent implementation calls intersect_ray_shape per face, causing ~200 allocations per call. For binary asteroid thermophysical simulations, this results in ~200 allocations × 2 bodies ×  number of time steps. Future optimization should implement true batch ray tracing for mutual  shadowing to reduce allocation overhead.\n\nnote: TODO\nParallel processing: Add multi-threading support using @threads for face-level calculations. Each face's shadow test is independent, making this function ideal for parallelization.\nSpatial optimization: Implement spatial data structures (e.g., octree) to pre-filter faces that could potentially be shadowed, reducing unnecessary ray tests.\nCaching for temporal coherence: For simulations with small time steps, implement caching to reuse shadow information from previous time steps when relative positions change gradually.\n\nArguments\n\nilluminated_faces : Boolean vector with current illumination state (will be modified)\nshape1            : Target shape model being shadowed (the shape receiving shadows)\nshape2            : Occluding shape model that may cast shadows on shape1 (must have BVH built)\nr☉₁               : Sun's position in shape1's frame\nr₁₂               : Shape2's position in shape1's frame (e.g., secondary's position from SPICE)\nR₁₂               : 3×3 rotation matrix from shape1 frame to shape2 frame\n\nReturns\n\nNO_ECLIPSE: No eclipse occurs (bodies are misaligned).\nPARTIAL_ECLIPSE: Some faces that were illuminated are now in shadow by the occluding body.\nTOTAL_ECLIPSE: All faces that were illuminated are now in shadow.\n\nThrows\n\nArgumentError if shape2 does not have BVH built. Call build_bvh!(shape2) before using this function.\n\nDescription\n\nThis function ONLY checks for mutual shadowing (eclipse) effects. It assumes that the illuminated_faces vector already contains the result of face orientation and/or self-shadowing checks. Only faces marked as true in the input will be tested for occlusion by the other body.\n\nExample with SPICE integration\n\n# Get positions and orientations from SPICE\net = ...               # Ephemeris time\nsun_pos1 = ...         # Sun's position in primary's frame\nsecondary_pos = ...    # Secondary's position in primary's frame  \nP2S = ...              # Rotation matrix from primary to secondary frame\n\n# Calcuate required transformation\nsun_pos2 = P2S * sun_pos1           # Sun's position in secondary's frame\nS2P = P2S'                          # Inverse rotation\nprimary_pos = -S2P * secondary_pos  # Primary's position in secondary's frame\n\n# Check self-shadowing first\nupdate_illumination!(illuminated_faces1, shape1, sun_pos1; with_self_shadowing=true)\nupdate_illumination!(illuminated_faces2, shape2, sun_pos2; with_self_shadowing=true)\n\n# For primary eclipsed by secondary\nstatus1 = apply_eclipse_shadowing!(illuminated_faces1, shape1, shape2, sun_pos1, secondary_pos, P2S)\n\n# For secondary eclipsed by primary\nstatus2 = apply_eclipse_shadowing!(illuminated_faces2, shape2, shape1, sun_pos2, primary_pos, S2P)\n\nSee also: update_illumination!, EclipseStatus\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.EclipseStatus","page":"Visibility Analysis","title":"AsteroidShapeModels.EclipseStatus","text":"EclipseStatus\n\nEnum representing the eclipse status between binary pairs.\n\nValues\n\nNO_ECLIPSE      : No eclipse occurs (bodies are misaligned).\nPARTIAL_ECLIPSE : Some faces are eclipsed by the occluding body.\nTOTAL_ECLIPSE   : All illuminated faces are eclipsed (complete shadow).\n\n\n\n\n\n","category":"type"},{"location":"api/visibility/#FaceVisibilityGraph-Functions","page":"Visibility Analysis","title":"FaceVisibilityGraph Functions","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_indices","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_indices","text":"get_visible_face_indices(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet indices of faces visible from the specified face.\n\nArguments\n\ngraph   : Face visibility graph\nface_idx: Source face index (1-based)\n\nReturns\n\nSubArray{Int}: View of face indices that are visible from the source face\n\nExample\n\n# Get all faces visible from face 100\nvisible_face_indices = get_visible_face_indices(graph, 100)\nprintln(\"Face 100 can see $(length(visible_face_indices)) faces\")\n\n# Iterate over visible faces\nfor j in visible_face_indices\n    println(\"Face 100 can see face $j\")\nend\n\nSee also: get_view_factors, get_visible_face_data\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_view_factors","page":"Visibility Analysis","title":"AsteroidShapeModels.get_view_factors","text":"get_view_factors(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet view factors from the specified face to all its visible faces.\n\nArguments\n\ngraph    : Face visibility graph\nface_idx : Source face index (1-based)\n\nReturns\n\nSubArray{Float64}: View of view factors corresponding to visible faces\n\nNotes\n\nThe returned array has the same length and ordering as get_visible_face_indices. View factors represent the fraction of radiation leaving face face_idx that directly reaches each visible face.\n\nExample\n\nvisible_face_indices = get_visible_face_indices(graph, 100)\nview_factors = get_view_factors(graph, 100)\n\n# Sum of view factors (always between 0 and 1)\n# - Near 0 for convex shapes (most radiation escapes to space)  \n# - Larger for concave regions (more reabsorption due to facing surfaces)\ntotal_vf = sum(view_factors)\nprintln(\"Total view factor from face 100: $total_vf\")\n\n# Pair indices with view factors\nfor (j, vf) in zip(visible_face_indices, view_factors)\n    println(\"Face 100 -> Face $j: view factor = $vf\")\nend\n\nSee also: get_visible_face_indices, view_factor\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_distances","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_distances","text":"get_visible_face_distances(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet distances to visible faces from the specified face.\n\nArguments\n\ngraph    : Face visibility graph\nface_idx : Source face index (1-based)\n\nReturns\n\nSubArray{Float64}: View of distances (in meters) from face center to visible face centers\n\nNotes\n\nThe returned array has the same length and ordering as get_visible_face_indices. Distances are computed between face centers during visibility graph construction.\n\nExample\n\nvisible_face_indices = get_visible_face_indices(graph, 100)\ndistances = get_visible_face_distances(graph, 100)\n\n# Find the closest visible face\nmin_dist, idx = findmin(distances)\nclosest_face_idx = visible_face_indices[idx]\nprintln(\"Closest visible face to face 100 is face $closest_face_idx at distance $min_dist m\")\n\nSee also: get_visible_face_indices, get_visible_face_directions\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_directions","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_directions","text":"get_visible_face_directions(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet unit direction vectors to visible faces from the specified face.\n\nArguments\n\ngraph    : Face visibility graph\nface_idx : Source face index (1-based)\n\nReturns\n\nSubArray{SVector{3,Float64}}: View of unit direction vectors from source face center to visible face centers\n\nNotes\n\nThe returned array has the same length and ordering as get_visible_face_indices. Each vector points from the source face center to a visible face center and has unit length.\n\nExample\n\nvisible_face_indices = get_visible_face_indices(graph, 100)\ndirections = get_visible_face_directions(graph, 100)\n\n# Calculate angle to each visible face\nface_normal = shape.face_normals[100]\nfor (j, dir) in zip(visible_face_indices, directions)\n    angle = acosd(face_normal ⋅ dir)  # Angle in degrees\n    println(\"Face 100 -> Face $j: angle = $(round(angle, digits=1))°\")\nend\n\nSee also: get_visible_face_indices, get_visible_face_distances\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_data","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_data","text":"get_visible_face_data(graph::FaceVisibilityGraph, face_idx::Int, idx::Int)\n\nGet the idx-th visible face data for the specified face.\n\nArguments\n\ngraph    : Face visibility graph\nface_idx : Source face index (1-based)\nidx      : Index within the visible faces list (1-based)\n\nReturns\n\nNamed tuple with fields:\n\nface_idx    : Index of the visible face\nview_factor : View factor between the faces\ndistance    : Distance between face centers\ndirection   : Unit direction vector from source to visible face\n\nExample\n\n# Get the third visible face from face 100\ndata = get_visible_face_data(graph, 100, 3)\nprintln(\"Face 100 can see face $(data.face_idx) with view factor $(data.view_factor)\")\n\nSee also: get_visible_face_indices, get_view_factors\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.num_visible_faces","page":"Visibility Analysis","title":"AsteroidShapeModels.num_visible_faces","text":"num_visible_faces(graph::FaceVisibilityGraph, face_idx::Int) -> Int\n\nGet the number of visible faces for the specified face.\n\nArguments\n\ngraph    : Face visibility graph\nface_idx : Source face index (1-based)\n\nReturns\n\nInt: Number of faces visible from the source face\n\nExample\n\n# Count visible faces for each face\nfor i in 1:graph.nfaces\n    n = num_visible_faces(graph, i)\n    if n > 100\n        println(\"Face $i can see $n other faces.\")\n    end\nend\n\n# Find the face with most visible faces\nmax_visible = 0\nmax_face = 0\nfor i in 1:graph.nfaces\n    n = num_visible_faces(graph, i)\n    if n > max_visible\n        max_visible = n\n        max_face = i\n    end\nend\nprintln(\"Face $max_face has the most visible faces: $max_visible\")\n\nSee also: get_visible_face_indices, FaceVisibilityGraph\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Face-Maximum-Elevations-Optimization-Benchmarks-(v0.4.2)","page":"v0.4.2 Face Max Elevations","title":"Face Maximum Elevations Optimization Benchmarks (v0.4.2)","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Overview","page":"v0.4.2 Face Max Elevations","title":"Overview","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"This document records the performance benchmarks for the face maximum elevations optimization feature introduced in v0.4.2.","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Test-Environment","page":"v0.4.2 Face Max Elevations","title":"Test Environment","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Date: 2025-01-21\nJulia Version: (to be filled)\nHardware: (to be filled)\nTest Models:\nSmall: ryugu_test.obj (5,932 faces)\nLarge: SHAPE_SFM_49k_v20180804.obj (49,152 faces)","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Benchmark-Scenario:-Full-Rotation-(72-steps,-5-increments)","page":"v0.4.2 Face Max Elevations","title":"Benchmark Scenario: Full Rotation (72 steps, 5° increments)","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Sun positions generated for one complete asteroid rotation with the sun on the equatorial plane.","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Small-Model-Results-(5,932-faces)","page":"v0.4.2 Face Max Elevations","title":"Small Model Results (5,932 faces)","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Total calculations: 427,104 illumination checks (5,932 × 72)\nOptimization effectiveness: 14.9%","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Method Time Relative Speed\nPseudo-convex model 848.0 μs 1.0x (baseline)\nSelf-shadowing (no opt) 30.2 ms 35.6x slower\nSelf-shadowing (with opt) 11.9 ms 14.0x slower","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Speedup from optimization: 2.53x","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Large-Model-Results-(49,152-faces)","page":"v0.4.2 Face Max Elevations","title":"Large Model Results (49,152 faces)","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Total calculations: 3,538,944 illumination checks (49,152 × 72)\nOptimization effectiveness: 10.7%","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Method Time Relative Speed\nPseudo-convex model 7.2 ms 1.0x (baseline)\nSelf-shadowing (no opt) 1.08 s 150x slower\nSelf-shadowing (with opt) 399.1 ms 55.4x slower","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Speedup from optimization: 2.7x","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Key-Findings","page":"v0.4.2 Face Max Elevations","title":"Key Findings","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Correctness: All optimized results match exactly with non-optimized calculations\nEffectiveness: 10-15% of ray tracing calculations are skipped when sun is on equatorial plane\nPerformance gain: 2.5-2.7x speedup despite relatively low skip rate\nScalability: Optimization benefits scale well with model size","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/#Implementation-Details","page":"v0.4.2 Face Max Elevations","title":"Implementation Details","text":"","category":"section"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"The optimization works by:","category":"page"},{"location":"benchmarks/v0.4.2_face_max_elevations/","page":"v0.4.2 Face Max Elevations","title":"v0.4.2 Face Max Elevations","text":"Pre-computing maximum elevation angles for each face\nSkipping ray tracing when sun elevation exceeds the maximum terrain elevation for that face\nThis is most effective when the sun is at high elevations","category":"page"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Core-Types","page":"Types","title":"Core Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.ShapeModel","page":"Types","title":"AsteroidShapeModels.ShapeModel","text":"ShapeModel\n\nA polyhedral shape model of an asteroid.\n\nFields\n\nnodes                 : Vector of node positions\nfaces                 : Vector of vertex indices of faces\nface_centers          : Center position of each face\nface_normals          : Normal vector of each face\nface_areas            : Area of each face\nface_visibility_graph : FaceVisibilityGraph for efficient visibility queries\nface_max_elevations   : Maximum elevation angle of the surrounding terrain from each face [rad]\nbvh                   : Bounding Volume Hierarchy for accelerated ray tracing\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.Ray","page":"Types","title":"AsteroidShapeModels.Ray","text":"Ray\n\nStructure representing a ray in 3D space.\n\nFields\n\norigin    : Ray origin point\ndirection : Ray direction vector (normalized)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.Sphere","page":"Types","title":"AsteroidShapeModels.Sphere","text":"Sphere\n\nStructure representing a sphere in 3D space.\n\nFields\n\ncenter : Center position of the sphere\nradius : Radius of the sphere (must be non-negative)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Result-Types","page":"Types","title":"Result Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.RayTriangleIntersectionResult","page":"Types","title":"AsteroidShapeModels.RayTriangleIntersectionResult","text":"RayTriangleIntersectionResult\n\nStructure representing the result of ray-triangle intersection test.\n\nFields\n\nhit      : true if intersection exists, false otherwise\ndistance : Distance from ray origin to intersection point\npoint    : Coordinates of the intersection point\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.RayShapeIntersectionResult","page":"Types","title":"AsteroidShapeModels.RayShapeIntersectionResult","text":"RayShapeIntersectionResult\n\nStructure representing the result of ray-shape intersection test.\n\nFields\n\nhit      : true if intersection exists, false otherwise\ndistance : Distance from ray origin to intersection point\npoint    : Coordinates of the intersection point\nface_idx : Index of the intersected face\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.RaySphereIntersectionResult","page":"Types","title":"AsteroidShapeModels.RaySphereIntersectionResult","text":"RaySphereIntersectionResult\n\nStructure representing the result of ray-sphere intersection test.\n\nFields\n\nhit       : true if intersection exists, false otherwise\ndistance1 : Distance from ray origin to first intersection point (entry)\ndistance2 : Distance from ray origin to second intersection point (exit)\npoint1    : Coordinates of the first intersection point (entry)\npoint2    : Coordinates of the second intersection point (exit)\n\nNotes\n\nIf hit is false, all other fields contain NaN values\ndistance1 ≤ distance2 (entry point comes before exit point)\nFor tangent rays, distance1 == distance2 and point1 == point2\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Face-Face-Visibility-Types","page":"Types","title":"Face-Face Visibility Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.FaceVisibilityGraph","page":"Types","title":"AsteroidShapeModels.FaceVisibilityGraph","text":"FaceVisibilityGraph\n\nEfficient visible face graph structure using CSR (Compressed Sparse Row) format. Stores face-to-face visibility relationships with associated view factors and geometric data.\n\nFields\n\nrow_ptr: Start index of visible face data for each face (length: nfaces + 1)\ncol_idx: Indices of visible faces (column indices in CSR format)\nview_factors: View factors for each visible face pair\ndistances: Distances between each visible face pair\ndirections: Unit direction vectors between each visible face pair\nnfaces: Total number of faces\nnnz: Number of non-zero elements (total number of visible face pairs)\n\nCSR Format\n\nThe CSR (Compressed Sparse Row) format provides:\n\nMemory efficiency: ~50% reduction compared to adjacency lists\nCache locality: Sequential access pattern for better performance\nFast iteration: Direct access to all visible faces from a given face\n\nData Access\n\nFor face i, its visible faces are stored at indices row_ptr[i] to row_ptr[i+1]-1:\n\nVisible face indices : col_idx[row_ptr[i]:row_ptr[i+1]-1]\nView factors         : view_factors[row_ptr[i]:row_ptr[i+1]-1]\nDistances            : distances[row_ptr[i]:row_ptr[i+1]-1]\nDirections           : directions[row_ptr[i]:row_ptr[i+1]-1]\n\nUse the provided API functions instead of direct field access:\n\nget_visible_face_indices(graph, face_idx) - Get indices of visible faces\nget_view_factors(graph, face_idx) - Get view factors to visible faces\nget_visible_face_distances(graph, face_idx) - Get distances to visible faces\nget_visible_face_directions(graph, face_idx) - Get direction vectors to visible faces\nget_visible_face_data(graph, face_idx, idx) - Get all data for a specific visible face\nnum_visible_faces(graph, face_idx) - Get number of visible faces\n\nExample\n\nIf face 1 sees faces [2,3] and face 2 sees faces [1,3,4]:\n\nrow_ptr = [1, 3, 6, 7]          # Face 1 data at [1:2], Face 2 at [3:5], Face 3 at [6:6]\ncol_idx = [2, 3, 1, 3, 4, ...]  # Visible face indices\n\nSee also: build_face_visibility_graph!, get_visible_face_indices\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Functions-to-accelerate-ray-tracing","page":"Types","title":"Functions to accelerate ray tracing","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.build_bvh!","page":"Types","title":"AsteroidShapeModels.build_bvh!","text":"build_bvh!(shape::ShapeModel)\n\nBuild a Bounding Volume Hierarchy (BVH) for the shape model for ray tracing. The BVH is stored in the shape.bvh field.\n\nnote: Note\nAs of v0.4.0, BVH must be pre-built before calling intersect_ray_shape. Use either with_bvh=true when loading or call this function explicitly.\n\nArguments\n\nshape: The shape model to build the BVH for\n\nReturns\n\nNothing (modifies shape in-place)\n\nPerformance\n\nBuilding time: O(n log n) where n is the number of faces\nRay intersection speedup: ~50x compared to previous implementations\n\nWhen to use\n\nRequired before calling intersect_ray_shape (as of v0.4.0)\nRequired for shape2 argument in apply_eclipse_shadowing! (as of v0.4.0)\nWhen loading a shape without with_bvh=true\nAlternative to with_bvh=true in load_shape_obj for existing shapes\n\nExample\n\n# Load shape without BVH\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000)\n\n# Build BVH before ray intersection (required in v0.4.0)\nbuild_bvh!(shape)\n\n# Now ray intersection can be performed\nray = Ray(SA[1000.0, 0.0, 0.0], SA[-1.0, 0.0, 0.0])\nresult = intersect_ray_shape(ray, shape)\n\n# Or load with BVH directly\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_bvh=true)\n\nNotes\n\nThis function creates bounding boxes for each triangular face and constructs an implicit BVH tree structure for efficient ray-shape intersection queries. The BVH uses the ImplicitBVH.jl package which provides cache-efficient traversal.\n\nSee also: load_shape_obj with with_bvh=true, intersect_ray_shape, apply_eclipse_shadowing!\n\n\n\n\n\n","category":"function"},{"location":"guides/migration/#Migration-Guide","page":"Migration Guide","title":"Migration Guide","text":"","category":"section"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"This guide helps you migrate your code when upgrading between major versions of AsteroidShapeModels.jl.","category":"page"},{"location":"guides/migration/#Migrating-to-v0.4.2","page":"Migration Guide","title":"Migrating to v0.4.2","text":"","category":"section"},{"location":"guides/migration/#New-Performance-Features","page":"Migration Guide","title":"New Performance Features","text":"","category":"section"},{"location":"guides/migration/#Face-Maximum-Elevation-Optimization","page":"Migration Guide","title":"Face Maximum Elevation Optimization","text":"","category":"section"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"The v0.4.2 release includes automatic performance optimizations for illumination calculations. No code changes are required to benefit from these improvements.","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"# Your existing code works as before, but ~2.5x faster!\nilluminated = isilluminated(shape, sun_position, face_idx; with_self_shadowing=true)","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"To disable the optimization (not recommended):","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"# Explicitly disable optimization\nilluminated = isilluminated(\n   shape, sun_position, face_idx; \n   with_self_shadowing=true, \n   use_elevation_optimization=false,\n)","category":"page"},{"location":"guides/migration/#Migrating-to-v0.4.1","page":"Migration Guide","title":"Migrating to v0.4.1","text":"","category":"section"},{"location":"guides/migration/#Breaking-Changes","page":"Migration Guide","title":"Breaking Changes","text":"","category":"section"},{"location":"guides/migration/#New-apply_eclipse_shadowing!-API","page":"Migration Guide","title":"New apply_eclipse_shadowing! API","text":"","category":"section"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"The parameter order has been changed for better SPICE integration:","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"# Old API (deprecated)\napply_eclipse_shadowing!(illuminated_faces, shape1, r☉₁, R₁₂, t₁₂, shape2)\n\n# New API (recommended)\napply_eclipse_shadowing!(illuminated_faces, shape1, shape2, r☉₁, r₁₂, R₁₂)","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"Key differences:","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"shape1 and shape2 are now grouped together\nr₁₂ (shape2's position in shape1's frame) replaces t₁₂\nMore intuitive parameter ordering","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"Migration example:","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"# If you have t₁₂, convert it to r₁₂:\nr₁₂ = -R₁₂' * t₁₂\n\n# Then use the new API:\napply_eclipse_shadowing!(illuminated, shape1, shape2, sun_position, r₁₂, R₁₂)","category":"page"},{"location":"guides/migration/#Migrating-to-v0.4.0","page":"Migration Guide","title":"Migrating to v0.4.0","text":"","category":"section"},{"location":"guides/migration/#New-Unified-Illumination-API","page":"Migration Guide","title":"New Unified Illumination API","text":"","category":"section"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"The illumination functions have been unified into a single API:","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"# Old APIs (removed)\nisilluminated_pseudoconvex(shape, sun_position, face_idx)\nisilluminated_with_self_shadowing(shape, sun_position, face_idx)\n\n# New unified API\nisilluminated(shape, sun_position, face_idx; with_self_shadowing=false)  # pseudo-convex\nisilluminated(shape, sun_position, face_idx; with_self_shadowing=true)   # with shadowing","category":"page"},{"location":"guides/migration/#Batch-Processing","page":"Migration Guide","title":"Batch Processing","text":"","category":"section"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"New batch processing functions for better performance:","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"# Process all faces at once\nilluminated = Vector{Bool}(undef, length(shape.faces))\nupdate_illumination!(illuminated, shape, sun_position; with_self_shadowing=true)","category":"page"},{"location":"guides/migration/#Future-Deprecations-(v0.5.0)","page":"Migration Guide","title":"Future Deprecations (v0.5.0)","text":"","category":"section"},{"location":"guides/migration/#Planned-Removals","page":"Migration Guide","title":"Planned Removals","text":"","category":"section"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"use_elevation_optimization parameter\nWill be removed in v0.5.0\nOptimization will become the default behavior\nStart removing explicit use_elevation_optimization=true from your code\nOld apply_eclipse_shadowing! signature\nThe deprecated signature with t₁₂ will be removed\nMigrate to the new API with r₁₂ parameter","category":"page"},{"location":"guides/migration/#Getting-Help","page":"Migration Guide","title":"Getting Help","text":"","category":"section"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"If you encounter issues during migration:","category":"page"},{"location":"guides/migration/","page":"Migration Guide","title":"Migration Guide","text":"Check the CHANGELOG for detailed changes\nReview the API documentation\nOpen an issue on GitHub","category":"page"},{"location":"api/roughness/#Surface-Roughness","page":"Surface Roughness","title":"Surface Roughness","text":"","category":"section"},{"location":"api/roughness/#Crater-Modeling","page":"Surface Roughness","title":"Crater Modeling","text":"","category":"section"},{"location":"api/roughness/#AsteroidShapeModels.crater_curvature_radius","page":"Surface Roughness","title":"AsteroidShapeModels.crater_curvature_radius","text":"crater_curvature_radius(r, h) -> R\n\nCalculate the curvature radius of a concave spherical segment.\n\nArguments\n\nr::Real: Crater radius (same units as h)\nh::Real: Crater depth (same units as r)\n\nReturns\n\nR::Real: Curvature radius of the spherical segment\n\nNotes\n\nThe curvature radius is calculated using the formula: R = (r² + h²) / 2h This represents the radius of the sphere from which the crater segment is cut.\n\nExample\n\n# Small bowl-shaped crater: 100m radius, 10m deep\nR = crater_curvature_radius(100.0, 10.0)  # Returns 505.0 m\n\n# Deeper crater (smaller curvature radius): 100m radius, 50m deep\nR = crater_curvature_radius(100.0, 50.0)  # Returns 125.0 m\n\nSee also: concave_spherical_segment\n\n\n\n\n\n","category":"function"},{"location":"api/roughness/#AsteroidShapeModels.concave_spherical_segment","page":"Surface Roughness","title":"AsteroidShapeModels.concave_spherical_segment","text":"concave_spherical_segment(r, h, xc, yc, x, y) -> z\n\nCalculate the z-coordinate (depth) of a concave spherical segment at a given (x,y) position.\n\nArguments\n\nr::Real  : Crater radius\nh::Real  : Crater depth (maximum depth at center)\nxc::Real : x-coordinate of crater center\nyc::Real : y-coordinate of crater center\nx::Real  : x-coordinate where to calculate z\ny::Real  : y-coordinate where to calculate z\n\nReturns\n\nz::Real: Depth below the surface (negative value inside, 0 outside crater)\n\nNotes\n\nReturns 0 for points outside the crater radius\nThe crater profile follows a spherical cap geometry\nAll spatial parameters should use consistent units\n\nExample\n\n# Crater at origin with 10m radius and 2m depth\nz_center = concave_spherical_segment(10.0, 2.0, 0.0, 0.0, 0.0, 0.0)   # Returns -2.0\nz_edge   = concave_spherical_segment(10.0, 2.0, 0.0, 0.0, 10.0, 0.0)  # Returns 0.0\nz_mid    = concave_spherical_segment(10.0, 2.0, 0.0, 0.0, 5.0, 0.0)   # Returns ~-0.6\n\nSee also: crater_curvature_radius\n\n\n\n\n\nconcave_spherical_segment(r, h; Nx=2^5, Ny=2^5, xc=0.5, yc=0.5) -> xs, ys, zs\n\nGenerate a grid representation of a concave spherical segment (crater).\n\nArguments\n\nr::Real : Crater radius (in normalized units, typically 0-1)\nh::Real : Crater depth (in same units as radius)\n\nKeyword Arguments\n\nNx::Integer=32 : Number of grid points in x-direction (default: 2^5)\nNy::Integer=32 : Number of grid points in y-direction (default: 2^5)\nxc::Real=0.5   : x-coordinate of crater center (normalized, 0-1)\nyc::Real=0.5   : y-coordinate of crater center (normalized, 0-1)\n\nReturns\n\nxs::LinRange: x-coordinates of grid points (0 to 1)\nys::LinRange: y-coordinates of grid points (0 to 1)\nzs::Matrix  : z-coordinates (depths) at each grid point\n\nNotes\n\nThe grid spans a unit square [0,1] × [0,1]\nz-values are negative inside the crater, 0 outside\nSuitable for use with load_shape_grid to create crater shape models\n\nExample\n\n# Generate a crater covering 40% of the domain, 0.1 units deep\nxs, ys, zs = concave_spherical_segment(0.4, 0.1; Nx=64, Ny=64)\n\n# Convert to shape model\nshape = load_shape_grid(xs, ys, zs)\n\n# Off-center crater\nxs, ys, zs = concave_spherical_segment(0.3, 0.05; xc=0.3, yc=0.7)\n\nSee also: load_shape_grid, grid_to_faces\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#FaceVisibilityGraph-Performance-Benchmark-Results-(v0.2.0)","page":"v0.2.0 Face Visibility Graph","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"This document records the performance comparison between the legacy adjacency list implementation and the new CSR-style FaceVisibilityGraph implementation introduced in PR #12.","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Test-Environment","page":"v0.2.0 Face Visibility Graph","title":"Test Environment","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Date: December 2024\nJulia Version: 1.11.5\nMachine: Apple M1/M2 (specify your machine)\nCommit: cae08e7 (feature/face-visibility-graph)","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Benchmark-Results","page":"v0.2.0 Face Visibility Graph","title":"Benchmark Results","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#1.-Small-Model-(Ryugu-test-shape-5,932-faces)","page":"v0.2.0 Face Visibility Graph","title":"1. Small Model (Ryugu test shape - 5,932 faces)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Visibility-Computation-Time","page":"v0.2.0 Face Visibility Graph","title":"Visibility Computation Time","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Legacy implementation: 391.08 ms\nFaceVisibilityGraph:   97.51 ms\nSpeed up: 4.01x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Memory-Usage","page":"v0.2.0 Face Visibility Graph","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Legacy (adjacency list): 11.7 MB\nFaceVisibilityGraph:     5.9 MB\nMemory reduction: 49.6%","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#2.-Large-Model-(Ryugu-49k-49,152-faces)","page":"v0.2.0 Face Visibility Graph","title":"2. Large Model (Ryugu 49k - 49,152 faces)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Visibility-Computation-Time-2","page":"v0.2.0 Face Visibility Graph","title":"Visibility Computation Time","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Legacy implementation: 29.064 seconds\nFaceVisibilityGraph:   28.778 seconds\nSpeed up: 1.01x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Memory-Usage-2","page":"v0.2.0 Face Visibility Graph","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Legacy (adjacency list): 561.92 MB\nFaceVisibilityGraph:     281.34 MB\nMemory reduction: 49.9%","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Query-Performance-(isilluminated-1000-queries)","page":"v0.2.0 Face Visibility Graph","title":"Query Performance (isilluminated - 1000 queries)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Legacy implementation: 52.88 μs\nFaceVisibilityGraph:   49.67 μs\nSpeed ratio: 1.06x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Verification-of-Results","page":"v0.2.0 Face Visibility Graph","title":"Verification of Results","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Computation-Results-Match","page":"v0.2.0 Face Visibility Graph","title":"Computation Results Match","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"All tests confirm that both implementations produce identical results:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"✅ Same number of visible face pairs\n✅ Same view factors (floating point equality)\n✅ Same distances\n✅ Same direction vectors\n✅ Same isilluminated results","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Test-Code-for-Verification","page":"v0.2.0 Face Visibility Graph","title":"Test Code for Verification","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"# From test/test_face_visibility_graph.jl (v0.2.1)\n@testset \"Legacy vs New Implementation\" begin\n    # Legacy implementation (v0.2.0)\n    shape_legacy = ShapeModel(nodes, faces)\n    find_visiblefacets!(shape_legacy, use_visibility_graph=false)\n    \n    # New implementation (v0.2.1)\n    shape_new = ShapeModel(nodes, faces)\n    find_visiblefacets!(shape_new, use_visibility_graph=true)\n    \n    for i in 1:length(faces)\n        @test length(legacy_visible) == length(new_visible)\n        @test sort(legacy_ids) == sort(new_ids)\n        # View factors, distances, and directions also match\n    end\nend","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Note: This comparison code was used in v0.2.1. In v0.3.0, the legacy implementation was completely removed.","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Key-Findings","page":"v0.2.0 Face Visibility Graph","title":"Key Findings","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"Small models (< 10k faces): Significant speedup (4x) due to reduced overhead\nLarge models (> 40k faces): Similar computation time, but 50% memory savings\nConsistent memory reduction: ~50% across all model sizes\nCache efficiency: Better sequential access patterns with CSR format","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Reproducing-These-Benchmarks","page":"v0.2.0 Face Visibility Graph","title":"Reproducing These Benchmarks","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"To reproduce these benchmarks on future versions:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"# Checkout the commit before FaceVisibilityGraph\ngit checkout e3529d2\n\n# Run legacy benchmark\njulia --project=. benchmark/compare_visibility.jl\n\n# Checkout the commit with FaceVisibilityGraph\ngit checkout feature/face-visibility-graph\n\n# Run comparison benchmark\njulia --project=. benchmark/compare_visibility.jl\njulia --project=. benchmark/benchmark_49k_shape.jl","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Migration-Notes","page":"v0.2.0 Face Visibility Graph","title":"Migration Notes","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Changes-in-v0.3.0","page":"v0.2.0 Face Visibility Graph","title":"Changes in v0.3.0","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"The following breaking changes were made in v0.3.0:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"The use_visibility_graph parameter was removed (FaceVisibilityGraph is now always used)\nThe visiblefacets field was removed from ShapeModel\nfind_visiblefacets! was renamed to build_face_visibility_graph!\nvisibility_graph was renamed to face_visibility_graph\nThe find_visible_facets parameter in ShapeModel constructor was renamed to with_face_visibility\nAccessor functions were renamed:\nget_visible_faces → get_visible_face_indices\n(other accessors remain the same)","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Current-API-(v0.3.0)","page":"v0.2.0 Face Visibility Graph","title":"Current API (v0.3.0+)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"# Create shape with face visibility\nshape = ShapeModel(nodes, faces; with_face_visibility=true)\n\n# Or load from OBJ file with visibility\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_face_visibility=true)\n\n# Or build visibility graph later\nbuild_face_visibility_graph!(shape)\n\n# Access visibility data\nvisible_face_indices = get_visible_face_indices(shape.face_visibility_graph, face_id)\nview_factors = get_view_factors(shape.face_visibility_graph, face_id)\ndistances = get_visible_face_distances(shape.face_visibility_graph, face_id)\ndirections = get_visible_face_directions(shape.face_visibility_graph, face_id)\n\n# Get specific visible face data\nvf_data = get_visible_face_data(shape.face_visibility_graph, face_id, visible_face_id)\n\n# Count visible faces\nn_visible = num_visible_faces(shape.face_visibility_graph, face_id)","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"v0.2.0 Face Visibility Graph","title":"v0.2.0 Face Visibility Graph","text":"These benchmark results serve as the baseline for future optimizations.","category":"page"},{"location":"api/io/#I/O-Functions","page":"I/O Functions","title":"I/O Functions","text":"","category":"section"},{"location":"api/io/#Loading-Shape-Models","page":"I/O Functions","title":"Loading Shape Models","text":"","category":"section"},{"location":"api/io/#AsteroidShapeModels.load_shape_obj","page":"I/O Functions","title":"AsteroidShapeModels.load_shape_obj","text":"load_shape_obj(shapepath; scale=1.0, with_face_visibility=false, with_bvh=false) -> ShapeModel\n\nLoad a shape model from a Wavefront OBJ file.\n\nArguments\n\nshapepath::String: Path to a Wavefront OBJ file\n\nKeyword Arguments\n\nscale::Real=1.0                  : Scale factor for node coordinates (e.g., 1000 to convert km to m)\nwith_face_visibility::Bool=false : Whether to build face-to-face visibility graph for illumination and thermophysical modeling\nwith_bvh::Bool=false             : Whether to build BVH for ray tracing (required for intersect_ray_shape and apply_eclipse_shadowing!)\n\nReturns\n\nShapeModel: Loaded shape model with computed geometric properties\n\nExamples\n\n# Load a shape model\nshape = load_shape_obj(\"asteroid.obj\")\n\n# Load with scaling and visibility computation\nshape = load_shape_obj(\"asteroid_km.obj\"; scale=1000, with_face_visibility=true)\n\n# Load with all features for comprehensive analysis\nshape = load_shape_obj(\"asteroid.obj\"; scale=1000, with_face_visibility=true, with_bvh=true)\n\nSee also: load_shape_grid, load_obj\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.load_obj","page":"I/O Functions","title":"AsteroidShapeModels.load_obj","text":"load_obj(shapepath::String; scale=1) -> nodes, faces\n\nLoad a 3D shape model from an OBJ file.\n\nArguments\n\nshapepath::String: Path to the OBJ file\n\nKeyword Arguments\n\nscale::Real=1: Scale factor to apply to all vertex coordinates. For example, use scale=1000 to convert from kilometers to meters\n\nReturns\n\nnodes::Vector{SVector{3,Float64}}: Array of vertex positions\nfaces::Vector{SVector{3,Int64}}: Array of triangular face definitions (1-indexed vertex indices)\n\nExamples\n\n# Load shape model in meters\nnodes, faces = load_obj(\"asteroid.obj\")\n\n# Load shape model and convert from km to m\nnodes, faces = load_obj(\"asteroid_km.obj\", scale=1000)\n\n# Get the number of nodes and faces\nprintln(\"Number of nodes: \", length(nodes))\nprintln(\"Number of faces: \", length(faces))\n\n# Access individual nodes and faces\nfirst_node = nodes[1]  # SVector{3, Float64}\nfirst_face = faces[1]  # SVector{3, Int} with node indices\n\nNotes\n\nThis function uses the FileIO/MeshIO packages to load OBJ files. Only triangular faces are supported.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.isobj","page":"I/O Functions","title":"AsteroidShapeModels.isobj","text":"isobj(filepath::String) -> Bool\n\nCheck if a file has the OBJ file extension.\n\nArguments\n\nfilepath::String: Path to the file to check\n\nReturns\n\nBool: true if the file has .obj extension, false otherwise\n\nExamples\n\nisobj(\"model.obj\")    # Returns true\nisobj(\"model.stl\")    # Returns false\nisobj(\"model.OBJ\")    # Returns false (case-sensitive)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Grid-Loading","page":"I/O Functions","title":"Grid Loading","text":"","category":"section"},{"location":"api/io/#AsteroidShapeModels.load_shape_grid","page":"I/O Functions","title":"AsteroidShapeModels.load_shape_grid","text":"load_shape_grid(xs, ys, zs; scale=1.0, with_face_visibility=false, with_bvh=false) -> ShapeModel\n\nConvert a regular grid (x, y) with z-values to a shape model.\n\nArguments\n\nxs::AbstractVector: x-coordinates of grid points\nys::AbstractVector: y-coordinates of grid points\nzs::AbstractMatrix: z-coordinates of grid points where zs[i,j] corresponds to (xs[i], ys[j])\n\nKeyword Arguments\n\nscale::Real=1.0                  : Scale factor to apply to all coordinates\nwith_face_visibility::Bool=false : Whether to build face-to-face visibility graph for illumination and thermophysical modeling\nwith_bvh::Bool=false             : Whether to build BVH for ray tracing (required for intersect_ray_shape and apply_eclipse_shadowing!)\n\nReturns\n\nShapeModel: Shape model with computed geometric properties\n\nExamples\n\n# Create a shape from elevation data\nxs = range(-10, 10, length=50)\nys = range(-10, 10, length=50)\nzs = [exp(-(x^2 + y^2)/10) for x in xs, y in ys]  # Gaussian surface\nshape = load_shape_grid(xs, ys, zs)\n\n# With scaling and visibility\nshape = load_shape_grid(xs, ys, zs, scale=1000, with_face_visibility=true)\n\n# With BVH acceleration (experimental)\nshape = load_shape_grid(xs, ys, zs; with_bvh=true)\n\nSee also: load_shape_obj, grid_to_faces\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.grid_to_faces","page":"I/O Functions","title":"AsteroidShapeModels.grid_to_faces","text":"grid_to_faces(xs::AbstractVector, ys::AbstractVector, zs::AbstractMatrix) -> nodes, faces\n\nConvert a regular grid (x, y) and corresponding z-coordinates to triangular facets.\n\n| ⧹| ⧹| ⧹|\n\nj+1 ・–C–D–・     |⧹ |⧹ |⧹ |     | ⧹| ⧹| ⧹| j   ・–A–B–・     |⧹ |⧹ |⧹ |        i  i+1\n\nArguments\n\nxs::AbstractVector: x-coordinates of grid points (should be sorted)\nys::AbstractVector: y-coordinates of grid points (should be sorted)\nzs::AbstractMatrix: z-coordinates of grid points where zs[i,j] corresponds to (xs[i], ys[j])\n\nReturns\n\nnodes::Vector{SVector{3,Float64}}: Array of 3D vertex positions\nfaces::Vector{SVector{3,Int}}: Array of triangular face definitions (1-indexed)\n\nNotes\n\nEach grid cell is divided into two triangles. The vertices are numbered sequentially row by row (j varies slowest).\n\nExamples\n\n# Create a simple 3x3 grid\nxs = [0.0, 1.0, 2.0]\nys = [0.0, 1.0, 2.0]\nzs = [i + j for i in 1:3, j in 1:3]  # z = x + y\nnodes, faces = grid_to_faces(xs, ys, zs)\n\nSee also: load_shape_grid\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Geometric-Operations","page":"Geometric Operations","title":"Geometric Operations","text":"","category":"section"},{"location":"api/geometry/#Face-Properties","page":"Geometric Operations","title":"Face Properties","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.face_center","page":"Geometric Operations","title":"AsteroidShapeModels.face_center","text":"face_center(vs::StaticVector{3, <:StaticVector{3}}) -> StaticVector{3}\nface_center(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> StaticVector{3}\n\nCalculate the center (centroid) of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle\n\nReturns\n\nStaticVector{3}: The center point of the triangle, computed as the arithmetic mean of the three vertices\n\nExamples\n\nv1 = SA[1.0, 0.0, 0.0]\nv2 = SA[0.0, 1.0, 0.0]\nv3 = SA[0.0, 0.0, 1.0]\ncenter = face_center(v1, v2, v3)  # Returns SA[1/3, 1/3, 1/3]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.face_normal","page":"Geometric Operations","title":"AsteroidShapeModels.face_normal","text":"face_normal(vs::StaticVector{3, <:StaticVector{3}}) -> StaticVector{3}\nface_normal(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> StaticVector{3}\n\nCalculate the unit normal vector of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle in counter-clockwise order\n\nReturns\n\nStaticVector{3}: The unit normal vector pointing outward from the face (following right-hand rule)\n\nNotes\n\nThe normal direction follows the right-hand rule based on the vertex ordering. For a counter-clockwise vertex ordering when viewed from outside, the normal points outward.\n\nExamples\n\nv1 = SA[1.0, 0.0, 0.0]\nv2 = SA[0.0, 1.0, 0.0]\nv3 = SA[0.0, 0.0, 0.0]\nnormal = face_normal(v1, v2, v3)  # Returns SA[0.0, 0.0, 1.0]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.face_area","page":"Geometric Operations","title":"AsteroidShapeModels.face_area","text":"face_area(vs::StaticVector{3, <:StaticVector{3}}) -> Real\nface_area(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> Real\n\nCalculate the area of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle\n\nReturns\n\nReal: The area of the triangle\n\nNotes\n\nThe area is computed using the cross product formula: area = ||(v2 - v1) × (v3 - v2)|| / 2\n\nExamples\n\n# Unit right triangle\nv1 = SA[0.0, 0.0, 0.0]\nv2 = SA[1.0, 0.0, 0.0]\nv3 = SA[0.0, 1.0, 0.0]\narea = face_area(v1, v2, v3)  # Returns 0.5\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.get_face_nodes","page":"Geometric Operations","title":"AsteroidShapeModels.get_face_nodes","text":"get_face_nodes(nodes, faces, face_idx) -> (v1, v2, v3)\n\nExtract three nodes of a triangular face from node and face arrays.\n\nArguments\n\nnodes: Array of node positions\nfaces: Array of face definitions (each face is an array of 3 node indices)\nface_idx: Index of the face to extract nodes from (1-based)\n\nReturns\n\nTuple of three nodes (v1, v2, v3)\n\nExamples\n\nnodes = [SA[0.0, 0.0, 0.0], SA[1.0, 0.0, 0.0], SA[0.0, 1.0, 0.0]]\nfaces = [SA[1, 2, 3]]\nv1, v2, v3 = get_face_nodes(nodes, faces, 1)\n\n\n\n\n\nget_face_nodes(shape::ShapeModel, face_idx::Integer) -> (v1, v2, v3)\n\nExtract three nodes of a triangular face from a shape model.\n\nArguments\n\nshape    : Shape model containing nodes and faces\nface_idx : Index of the face in the shape model\n\nReturns\n\nTuple of three nodes (v1, v2, v3)\n\nExamples\n\n# Assuming shape is a loaded ShapeModel\nv1, v2, v3 = get_face_nodes(shape, 1)  # Get nodes of the first face\n\nSee also: get_face_nodes(nodes, faces, face_idx)\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Shape-Properties","page":"Geometric Operations","title":"Shape Properties","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.polyhedron_volume","page":"Geometric Operations","title":"AsteroidShapeModels.polyhedron_volume","text":"polyhedron_volume(nodes, faces) -> Float64\npolyhedron_volume(shape::ShapeModel) -> Float64\n\nCalculate the volume of a polyhedron using the divergence theorem.\n\nArguments\n\nnodes: Array of vertex positions\nfaces: Array of triangular face definitions (vertex indices)\nshape::ShapeModel: A shape model containing nodes and faces\n\nReturns\n\nFloat64: Volume of the polyhedron\n\nNotes\n\nThe volume is computed using the formula: V = (1/6) * Σ (A × B) · C where A, B, C are the vertices of each triangular face. The shape must be a closed polyhedron with consistently oriented faces.\n\nExamples\n\n# Unit cube\nnodes = [SA[0,0,0], SA[1,0,0], SA[1,1,0], SA[0,1,0],\n         SA[0,0,1], SA[1,0,1], SA[1,1,1], SA[0,1,1]]\nfaces = [SA[1,2,3], SA[1,3,4], ...]  # Define all 12 triangular faces\nvol = polyhedron_volume(nodes, faces)  # Returns 1.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.equivalent_radius","page":"Geometric Operations","title":"AsteroidShapeModels.equivalent_radius","text":"equivalent_radius(VOLUME::Real) -> Float64\nequivalent_radius(shape::ShapeModel) -> Float64\n\nCalculate the radius of a sphere with the same volume as the given volume or shape.\n\nArguments\n\nVOLUME::Real: Volume of the object\nshape::ShapeModel: A shape model to calculate volume from\n\nReturns\n\nFloat64: Radius of the equivalent sphere\n\nNotes\n\nThe equivalent radius is calculated as: r = (3V/4π)^(1/3)\n\nExamples\n\n# Sphere with radius 2\nvolume = 4π/3 * 2^3\nr_eq = equivalent_radius(volume)  # Returns 2.0\n\n# From shape model\nshape = load_shape_obj(\"asteroid.obj\")\nr_eq = equivalent_radius(shape)\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.maximum_radius","page":"Geometric Operations","title":"AsteroidShapeModels.maximum_radius","text":"maximum_radius(nodes) -> Float64\nmaximum_radius(shape::ShapeModel) -> Float64\n\nCalculate the maximum distance from the origin to any vertex.\n\nArguments\n\nnodes: Array of vertex positions\nshape::ShapeModel: A shape model containing nodes\n\nReturns\n\nFloat64: Maximum distance from origin to any vertex\n\nNotes\n\nThis represents the radius of the smallest sphere centered at the origin that contains all vertices of the shape.\n\nExamples\n\nnodes = [SA[1,0,0], SA[0,2,0], SA[0,0,3]]\nr_max = maximum_radius(nodes)  # Returns 3.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.minimum_radius","page":"Geometric Operations","title":"AsteroidShapeModels.minimum_radius","text":"minimum_radius(nodes) -> Float64\nminimum_radius(shape::ShapeModel) -> Float64\n\nCalculate the minimum distance from the origin to any vertex.\n\nArguments\n\nnodes: Array of vertex positions\nshape::ShapeModel: A shape model containing nodes\n\nReturns\n\nFloat64: Minimum distance from origin to any vertex\n\nNotes\n\nThis represents the radius of the largest sphere centered at the origin that fits entirely inside the convex hull of the vertices.\n\nExamples\n\nnodes = [SA[1,0,0], SA[0,2,0], SA[0,0,3]]\nr_min = minimum_radius(nodes)  # Returns 1.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Angle-Calculations","page":"Geometric Operations","title":"Angle Calculations","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.angle_rad","page":"Geometric Operations","title":"AsteroidShapeModels.angle_rad","text":"angle_rad(v1, v2) -> Float64\n\nCalculate the angle between two vectors in radians.\n\nArguments\n\nv1::AbstractVector : First vector\nv2::AbstractVector : Second vector\n\nReturns\n\nFloat64: Angle between vectors in radians [0, π]\n\nNotes\n\nVectors are automatically normalized before angle calculation\nUses clamping to handle numerical errors in dot product\nResult is always in range [0, π] regardless of vector orientations\n\nExample\n\n# Perpendicular vectors\nangle = angle_rad([1, 0, 0], [0, 1, 0])  # Returns π/2\n\n# Opposite vectors\nangle = angle_rad([1, 0, 0], [-1, 0, 0])  # Returns π\n\n# Same direction\nangle = angle_rad([1, 0, 0], [2, 0, 0])  # Returns 0.0\n\nSee also: angle_deg\n\n\n\n\n\nangle_rad(v1::AbstractVector{<:AbstractVector}, v2::AbstractVector{<:AbstractVector}) -> Vector{Float64}\n\nCalculate angles between corresponding pairs of vectors in two arrays (broadcast version).\n\nArguments\n\nv1: Array of first vectors\nv2: Array of second vectors (must have same length as v1)\n\nReturns\n\nArray of angles in radians between corresponding vector pairs\n\nExamples\n\nv1s = [SA[1,0,0], SA[0,1,0]]\nv2s = [SA[0,1,0], SA[1,0,0]]\nangles = angle_rad(v1s, v2s)  # Returns [π/2, π/2]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.angle_deg","page":"Geometric Operations","title":"AsteroidShapeModels.angle_deg","text":"angle_deg(v1, v2) -> Float64\n\nCalculate the angle between two vectors in degrees.\n\nArguments\n\nv1::AbstractVector : First vector\nv2::AbstractVector : Second vector\n\nReturns\n\nFloat64: Angle between vectors in degrees [0, 180]\n\nNotes\n\nThis is a convenience function that converts the result of angle_rad to degrees.\n\nExample\n\n# Perpendicular vectors\nangle = angle_deg([1, 0, 0], [0, 1, 0])  # Returns 90.0\n\n# Opposite vectors\nangle = angle_deg([1, 0, 0], [-1, 0, 0])  # Returns 180.0\n\n# 45 degree angle\nangle = angle_deg([1, 0, 0], [1, 1, 0])  # Returns 45.0\n\nSee also: angle_rad\n\n\n\n\n\nangle_deg(v1::AbstractVector{<:AbstractVector}, v2::AbstractVector{<:AbstractVector}) -> Vector{Float64}\n\nCalculate angles between corresponding pairs of vectors in two arrays (broadcast version).\n\nArguments\n\nv1: Array of first vectors\nv2: Array of second vectors (must have same length as v1)\n\nReturns\n\nArray of angles in degrees between corresponding vector pairs\n\nExamples\n\nv1s = [SA[1,0,0], SA[0,1,0]]\nv2s = [SA[0,1,0], SA[1,0,0]]\nangles = angle_deg(v1s, v2s)  # Returns [90.0, 90.0]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.solar_phase_angle","page":"Geometric Operations","title":"AsteroidShapeModels.solar_phase_angle","text":"solar_phase_angle(sun, target, observer) -> Float64\n\nCalculate the solar phase angle (sun-target-observer angle).\n\nArguments\n\nsun::AbstractVector      : Sun position vector in the same reference frame\ntarget::AbstractVector   : Target (asteroid) position vector\nobserver::AbstractVector : Observer position vector\n\nReturns\n\nFloat64: Solar phase angle in radians [0, π]\n\nNotes\n\nThe phase angle is a key parameter in asteroid photometry:\n\n0° (0 rad)    : Opposition (Sun behind observer)\n90° (π/2 rad) : Quadrature\n180° (π rad)  : Conjunction (Sun behind target)\n\nPhase angle affects apparent brightness through phase functions.\n\nExample\n\n# Opposition geometry (phase angle ≈ 0)\nsun = [1.0, 0.0, 0.0] * 1.496e11       # 1 au from origin\nobserver = [1.0, 0.0, 0.0] * 1.495e11  # Slightly closer\ntarget = [0.0, 0.0, 0.0]               # At origin\nα = solar_phase_angle(sun, target, observer)\nprintln(\"Phase angle: $(rad2deg(α))°\")  # ≈ 0°\n\n# Quadrature geometry (phase angle = 90°)\nobserver = [0.0, 1.0, 0.0] * 1.496e11\nα = solar_phase_angle(sun, target, observer)\nprintln(\"Phase angle: $(rad2deg(α))°\")  # = 90°\n\nSee also: solar_elongation_angle, angle_rad\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.solar_elongation_angle","page":"Geometric Operations","title":"AsteroidShapeModels.solar_elongation_angle","text":"solar_elongation_angle(sun, observer, target) -> Float64\n\nCalculate the solar elongation angle (sun-observer-target angle).\n\nArguments\n\nsun::AbstractVector      : Sun position vector in the same reference frame\nobserver::AbstractVector : Observer position vector\ntarget::AbstractVector   : Target (asteroid) position vector\n\nReturns\n\nFloat64: Solar elongation angle in radians [0, π]\n\nNotes\n\nThe elongation angle determines observability from Earth:\n\n0° (0 rad)    : Conjunction (target near Sun, unobservable)\n90° (π/2 rad) : Quadrature (good observability)\n180° (π rad)  : Opposition (best observability)\n\nObjects with small elongation angles are difficult to observe due to sunlight and proximity to the Sun in the sky.\n\nExample\n\n# Near conjunction (small elongation, poor observability)\nsun = [1.0, 0.0, 0.0] * 1.496e11  # 1 au\nobserver = [0.0, 0.0, 0.0]  # Earth at origin\ntarget = [1.1, 0.0, 0.0] * 1.496e11  # Just beyond Sun\nε = solar_elongation_angle(sun, observer, target)\nprintln(\"Elongation: $(rad2deg(ε))°\")  # Small angle\n\n# Opposition (maximum elongation)\ntarget = [-1.0, 0.0, 0.0] * 1.496e11  # Opposite side from Sun\nε = solar_elongation_angle(sun, observer, target)\nprintln(\"Elongation: $(rad2deg(ε))°\")  # ≈ 180°\n\nSee also: solar_phase_angle, angle_rad\n\n\n\n\n\n","category":"function"},{"location":"guides/bvh_usage/#BVH-(Bounding-Volume-Hierarchy)-Usage-Guide","page":"BVH Usage","title":"BVH (Bounding Volume Hierarchy) Usage Guide","text":"","category":"section"},{"location":"guides/bvh_usage/#Overview","page":"BVH Usage","title":"Overview","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"AsteroidShapeModels.jl uses BVH (Bounding Volume Hierarchy) acceleration structures to optimize ray-shape intersection operations. The BVH implementation is provided by the ImplicitBVH.jl package and is automatically utilized for optimal performance.","category":"page"},{"location":"guides/bvh_usage/#How-BVH-is-Used","page":"BVH Usage","title":"How BVH is Used","text":"","category":"section"},{"location":"guides/bvh_usage/#Fixed-Optimal-Implementations","page":"BVH Usage","title":"Fixed Optimal Implementations","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Each operation in the package uses a fixed implementation that has been determined to be optimal through benchmarking:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Ray-shape intersection: Uses BVH implementation (~50x speedup over naive approach)\nFace visibility graph: Uses non-BVH algorithm with candidate filtering (2x faster than BVH)\nIllumination checks: Uses non-BVH implementation with precomputed visibility graph","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"These implementations are not user-configurable - the package uses the proven fastest approach for each operation.","category":"page"},{"location":"guides/bvh_usage/#When-to-Use-with_bvhtrue","page":"BVH Usage","title":"When to Use with_bvh=true","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"The with_bvh parameter in load_shape_obj controls whether the BVH is built during model loading:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"# Build BVH during loading (recommended for ray tracing applications)\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_bvh=true)\n\n# Load without BVH (BVH will be built on first ray intersection)\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_bvh=false)\n# or simply omit the parameter (default is `with_bvh=false`):\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000)","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Use with_bvh=true when:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"You plan to perform many ray intersections\nYou want predictable performance (avoid first-call overhead)\nYou're building a ray tracing application","category":"page"},{"location":"guides/bvh_usage/#Manual-BVH-Construction","page":"BVH Usage","title":"Manual BVH Construction","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"You can also build the BVH manually after loading:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"shape = load_shape_obj(\"asteroid.obj\"; scale=1000)\nbuild_bvh!(shape)  # Build BVH in-place","category":"page"},{"location":"guides/bvh_usage/#Performance-Characteristics","page":"BVH Usage","title":"Performance Characteristics","text":"","category":"section"},{"location":"guides/bvh_usage/#Ray-Intersection-Performance","page":"BVH Usage","title":"Ray Intersection Performance","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"With BVH acceleration:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Single ray: ~3-5 μs per intersection (for 50k face models)\nComplexity: O(log n) where n is the number of faces\nMemory overhead: ~100-200 bytes per face","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Without BVH (first call only):","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Additional overhead for BVH construction\nSubsequent calls use the cached BVH","category":"page"},{"location":"guides/bvh_usage/#Batch-Processing","page":"BVH Usage","title":"Batch Processing","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"For multiple rays, use batch processing for optimal performance:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"# Process multiple rays efficiently\nrays = [Ray(origin, direction) for ...]\n\n# Vector of rays - returns vector of results\nresults = intersect_ray_shape(rays, shape)\n\n# Matrix of rays - preserves grid structure\nray_grid = [Ray(...) for x in 1:nx, y in 1:ny]\nresult_grid = intersect_ray_shape(ray_grid, shape)\n\n# Raw arrays for maximum performance\norigins    = zeros(3, n_rays)  # Each column is a ray origin\ndirections = zeros(3, n_rays)  # Each column is a ray direction\n# ... fill arrays ...\nresults = intersect_ray_shape(shape, origins, directions)","category":"page"},{"location":"guides/bvh_usage/#Implementation-Details","page":"BVH Usage","title":"Implementation Details","text":"","category":"section"},{"location":"guides/bvh_usage/#Why-Different-Algorithms-for-Different-Operations?","page":"BVH Usage","title":"Why Different Algorithms for Different Operations?","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Ray intersection: BVH excels at single ray queries by quickly eliminating non-intersecting faces\nFace visibility: Non-BVH algorithm with candidate filtering is more efficient because:\nIt processes many face pairs simultaneously\nDistance-based sorting provides natural occlusion culling\nThe specific geometry of face-to-face visibility favors this approach\nIllumination: Leverages precomputed visibility graph for O(1) lookup of potentially occluding faces","category":"page"},{"location":"guides/bvh_usage/#Memory-Considerations","page":"BVH Usage","title":"Memory Considerations","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"The BVH structure requires additional memory:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Tree nodes: ~32 bytes per face\nBounding boxes: ~24 bytes per face\nTotal overhead: ~100-200 bytes per face (depending on tree depth)","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"For a 50k face model, expect ~5-10 MB additional memory usage.","category":"page"},{"location":"guides/bvh_usage/#Example:-Ray-Tracing-Application","page":"BVH Usage","title":"Example: Ray Tracing Application","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"using AsteroidShapeModels\nusing StaticArrays\n\n# Load model with BVH for ray tracing\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_bvh=true)\n\n# Camera rays for rendering\nfunction render_image(shape, camera_pos, camera_dir, width, height)\n    rays = Matrix{Ray}(undef, height, width)\n    \n    # Generate camera rays\n    for y in 1:height, x in 1:width\n        # ... compute ray direction ...\n        rays[y, x] = Ray(camera_pos, ray_dir)\n    end\n    \n    # Batch process all rays\n    intersections = intersect_ray_shape(rays, shape)\n    \n    # Process results\n    image = zeros(height, width)\n    for y in 1:height, x in 1:width\n        if intersections[y, x].hit\n            # Compute shading, distance, etc.\n            image[y, x] = compute_pixel_value(intersections[y, x])\n        end\n    end\n    \n    return image\nend","category":"page"},{"location":"guides/bvh_usage/#Best-Practices","page":"BVH Usage","title":"Best Practices","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Preload BVH for ray tracing applications using with_bvh=true\nUse batch processing when intersecting multiple rays\nLet the package choose the optimal algorithm for each operation\nMonitor memory usage for very large models (>1M faces)","category":"page"},{"location":"guides/bvh_usage/#See-Also","page":"BVH Usage","title":"See Also","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"intersect_ray_shape - Ray-shape intersection function\nbuild_bvh! - Manual BVH construction\nPerformance Tips - General optimization guidelines","category":"page"},{"location":"#AsteroidShapeModels.jl","page":"Home","title":"AsteroidShapeModels.jl","text":"","category":"section"},{"location":"#AsteroidShapeModels.AsteroidShapeModels","page":"Home","title":"AsteroidShapeModels.AsteroidShapeModels","text":"AsteroidShapeModels\n\nA Julia package for geometric processing and analysis of asteroid shape models.\n\nThis package provides comprehensive tools for working with polyhedral shape models of asteroids, including loading from OBJ files, computing geometric properties, ray-shape intersection, visibility analysis, and surface roughness modeling.\n\nMain Types\n\nShapeModel: Core data structure for polyhedral shapes\nRay: Ray for ray casting operations\nFaceVisibilityGraph: CSR-style data structure for face-to-face visibility\n\nKey Functions\n\nShape I/O: load_shape_obj, load_obj, load_shape_grid\nGeometric properties: face_center, face_normal, face_area, polyhedron_volume\nRay intersection: intersect_ray_triangle, intersect_ray_shape\nVisibility: build_face_visibility_graph!, isilluminated, view_factor\nShape analysis: equivalent_radius, maximum_radius, minimum_radius\n\nExample\n\nusing AsteroidShapeModels\n\n# Load an asteroid shape model with face-face visibility\nshape = load_shape_obj(\"path/to/shape.obj\", scale=1000, with_face_visibility=true)  # Convert km to m\n\n# Access to face properties\nshape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face\n\nSee the documentation for detailed usage examples and API reference.\n\n\n\n\n\n","category":"module"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AsteroidShapeModels.jl provides comprehensive tools for working with polyhedral shape models of asteroids. The package supports:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loading shape models from OBJ files\nComputing geometric properties (area, volume, normals)\nRay-shape intersection testing with optional BVH acceleration\nFace-to-face visibility analysis with BVH support\nSurface roughness modeling\nIllumination calculations","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AsteroidShapeModels\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AsteroidShapeModels\nusing StaticArrays\n\n# Load an asteroid shape model\n# - `path/to/shape.obj` is the path to your OBJ file (mandatory)\n# - `scale` : scale factor for the shape model (e.g., 1000 for km to m conversion)\n# - `with_face_visibility` : whether to build face-to-face visibility graph for illumination checking and thermophysical modeling\n# - `with_bvh` : whether to build BVH for ray tracing\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_face_visibility=true, with_bvh=true)\n\n# Or you can build face-face visibility graph and/or BVH for an existing shape\n# build_face_visibility_graph!(shape)\n# build_bvh!(shape)\n\n# NEW in v0.4.0: Unified illumination API\nsun_position = SA[149597870700, 0.0, 0.0]  # Sun 1 au away\nilluminated = Vector{Bool}(undef, length(shape.faces))\nupdate_illumination!(illuminated, shape, sun_position; with_self_shadowing=false)\n\n# Access to face properties\nshape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Shape-Model-Management","page":"Home","title":"Shape Model Management","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load polyhedral models from OBJ files\nAutomatic computation of face centers, normals, and areas\nSupport for scaling and coordinate transformations","category":"page"},{"location":"#Geometric-Analysis","page":"Home","title":"Geometric Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Face properties: center, normal, area\nShape properties: volume, equivalent radius\nBounding box computation","category":"page"},{"location":"#Ray-Intersection","page":"Home","title":"Ray Intersection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast ray-triangle intersection using Möller–Trumbore algorithm\nRay-shape intersection with optional BVH acceleration (~50x speedup)\nBounding box culling for efficiency","category":"page"},{"location":"#Visibility-Analysis","page":"Home","title":"Visibility Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Face-to-face visibility computation with optimized non-BVH algorithm\nView factor calculations for thermal modeling\nIllumination determination with configurable self-shadowing\nBatch illumination updates for all faces\nBinary asteroid mutual shadowing and eclipse detection","category":"page"},{"location":"#Surface-Roughness","page":"Home","title":"Surface Roughness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Crater modeling\nSurface curvature analysis","category":"page"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"types.jl - Core data structures and type definitions\nobj_io.jl - OBJ file loading and parsing\nface_properties.jl - Face geometric computations (center, normal, area)\nshape_operations.jl - Shape-level operations (volume, radius calculations)\nray_intersection.jl - Ray casting and intersection algorithms\nface_visibility_graph.jl - Face-to-face visibility graph and view factor calculations\nillumination.jl - Illumination analysis and shadow testing\neclipse_shadowing.jl - Eclipse shadowing for binary asteroid systems\ngeometry_utils.jl - Geometric helper functions and angle calculations\nroughness.jl - Surface roughness and crater modeling","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates the main features of AsteroidShapeModels.jl through practical examples.","category":"page"},{"location":"tutorial/#Loading-a-Shape-Model","page":"Tutorial","title":"Loading a Shape Model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using AsteroidShapeModels\nusing StaticArrays\n\n# Load from OBJ file\nshape = load_shape_obj(\"path/to/shape.obj\")\n\n# Load with scaling (e.g., converting km to m)\nshape_m = load_shape_obj(\"path/to/shape.obj\"; scale=1000)\n\n# Access shape properties\nprintln(\"Number of nodes : $(length(shape.nodes))\")\nprintln(\"Number of faces : $(length(shape.faces))\")","category":"page"},{"location":"tutorial/#Working-with-Face-Properties","page":"Tutorial","title":"Working with Face Properties","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"shape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face\n\n# Get properties of face 1\nshape.face_centers[1]  # Center position of each face\nshape.face_normals[1]  # Normal vector of each face\nshape.face_areas[1]    # Area of of each face","category":"page"},{"location":"tutorial/#Shape-Analysis","page":"Tutorial","title":"Shape Analysis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Compute shape properties\nvolume = polyhedron_volume(shape)\neq_radius = equivalent_radius(shape)\nmax_radius = maximum_radius(shape)\nmin_radius = minimum_radius(shape)\n\nprintln(\"Volume            : $volume m³\")\nprintln(\"Equivalent radius : $eq_radius m\")\nprintln(\"Maximum radius    : $max_radius m\")\nprintln(\"Minimum radius    : $min_radius m\")","category":"page"},{"location":"tutorial/#Face-Visibility-Analysis","page":"Tutorial","title":"Face Visibility Analysis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Load shape with face visibility computation\nshape_vis = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_face_visibility=true)\n\n# Or build visibility graph for existing shape\nbuild_face_visibility_graph!(shape)\n\n# Access visibility data for a specific face\nface_id = 100\nvisible_faces = get_visible_face_indices(shape.face_visibility_graph, face_id)\nview_factors = get_view_factors(shape.face_visibility_graph, face_id)\nnum_visible = num_visible_faces(shape.face_visibility_graph, face_id)\n\nprintln(\"Face $face_id can see $num_visible other faces.\")\nprintln(\"Total view factor: \", sum(view_factors))\n\n# Check if a face is illuminated by the sun\nsun_position = SA[1.5e11, 0.0, 0.0]  # Sun 1 au away along x-axis\n\n# Without self-shadowing (pseudo-convex model)\nilluminated = isilluminated(shape, sun_position, face_id; with_self_shadowing=false)\nprintln(\"Face $face_id is \", illuminated ? \"illuminated\" : \"in shadow\")\n\n# With self-shadowing (requires `face_visibility_graph` to be built)\nilluminated = isilluminated(shape_vis, sun_position, face_id; with_self_shadowing=true)\nprintln(\"Face $face_id is \", illuminated ? \"illuminated\" : \"in shadow\")","category":"page"},{"location":"tutorial/#Batch-Illumination-Updates","page":"Tutorial","title":"Batch Illumination Updates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Efficiently update illumination state for all faces\nilluminated = Vector{Bool}(undef, length(shape.faces))\n\n# Without self-shadowing (fast, pseudo-convex model)\nupdate_illumination!(illuminated, shape, sun_position; with_self_shadowing=false)\nn_illuminated = count(illuminated)\nprintln(\"$n_illuminated faces are illuminated (pseudo-convex model).\")\n\n# With self-shadowing (requires `face_visibility_graph` to be built)\nupdate_illumination!(illuminated, shape_vis, sun_position; with_self_shadowing=true)\nn_illuminated = count(illuminated)\nprintln(\"$n_illuminated faces are illuminated (with self-shadowing).\")","category":"page"},{"location":"tutorial/#Binary-Asteroid-Shadowing","page":"Tutorial","title":"Binary Asteroid Shadowing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# For binary asteroid systems, check mutual shadowing effects\n# Assume we have two shape models: shape1 (primary) and shape2 (secondary)\nshape1 = load_shape_obj(\"primary_shape.obj\"; scale=1000, with_face_visibility=true, with_bvh=true)\nshape2 = load_shape_obj(\"secondary_shape.obj\"; scale=1000, with_face_visibility=true, with_bvh=true)\n\n# Define relative position and orientation\n# R12: rotation from shape1 frame to shape2 frame\n# R21: rotation from shape2 frame to shape1 frame\n# t12: translation from shape1 origin to shape2 origin\n# t21: translation from shape2 origin to shape1 origin\nR12 = SA[1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]  # Identity (no rotation)\nt12 = SA[2000.0, 0.0, 0.0]  # 2 km separation\n\nR21 = R12'         # Inverse rotation\nt21 = -R12' * t12  # Inverse translation\n\n# Sun position in each body's frame\nsun_position1 = SA[1.5e11, 0.0, 0.0]\nsun_position2 = sun_position1 - t12  # Transform to shape2's frame\n\n# First, check self-shadowing for each body\nilluminated1 = Vector{Bool}(undef, length(shape1.faces))\nilluminated2 = Vector{Bool}(undef, length(shape2.faces))\nupdate_illumination!(illuminated1, shape1, sun_position1; with_self_shadowing=true)\nupdate_illumination!(illuminated2, shape2, sun_position2; with_self_shadowing=true)\n\n# Then apply mutual shadowing\nstatus1 = apply_eclipse_shadowing!(illuminated1, shape1, sun_position1, R12, t12, shape2)\nstatus2 = apply_eclipse_shadowing!(illuminated2, shape2, sun_position2, R21, t21, shape1)\n\n# Check eclipse status\nif status1 == NO_ECLIPSE\n    println(\"Primary is not eclipsed by secondary.\")\nelseif status1 == PARTIAL_ECLIPSE\n    println(\"Primary is partially eclipsed by secondary.\")\nelseif status1 == TOTAL_ECLIPSE\n    println(\"Primary is totally eclipsed by secondary.\")\nend","category":"page"},{"location":"tutorial/#Ray-Shape-Intersection","page":"Tutorial","title":"Ray-Shape Intersection","text":"","category":"section"},{"location":"tutorial/#Single-Ray","page":"Tutorial","title":"Single Ray","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Ensure BVH is built for ray intersection\nif isnothing(shape.bvh)\n    build_bvh!(shape)\nend\n\n# Define a ray\norigin = SA[1000.0, 0.0, 0.0]  # Start 1 km away\ndirection = normalize(SA[-1.0, 0.0, 0.0])  # Point toward origin\nray = Ray(origin, direction)\n\n# Find intersection with shape\nresult = intersect_ray_shape(ray, shape)\n\nif result.hit\n    println(\"Ray hit face $(result.face_idx) at distance $(result.distance).\")\n    println(\"Hit point: \", result.point)\nelse\n    println(\"Ray missed the shape.\")\nend","category":"page"},{"location":"tutorial/#Batch-Ray-Processing","page":"Tutorial","title":"Batch Ray Processing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Process multiple rays efficiently\nrays = [Ray(SA[x, 0.0, 1000.0], SA[0.0, 0.0, -1.0]) for x in -500:100:500]\nresults = intersect_ray_shape(rays, shape)\n\n# Count hits\nn_hits = count(r -> r.hit, results)\nprintln(\"$n_hits out of $(length(rays)) rays hit the shape.\")\n\n# Process rays in a grid pattern\nray_grid = [Ray(SA[x, y, 1000.0], SA[0.0, 0.0, -1.0]) \n            for x in -500:100:500, y in -500:100:500]\nresult_grid = intersect_ray_shape(ray_grid, shape)\n\n# Results maintain the same shape as input\n@assert size(result_grid) == size(ray_grid)\n\n# Alternative: Use matrix interface for maximum performance\nn_rays = 100\norigins = rand(3, n_rays) .* 2000 .- 1000  # Random origins\ndirections = normalize.(eachcol(rand(3, n_rays) .- 0.5))\ndirections = hcat(directions...)  # Convert back to matrix\n\nresults = intersect_ray_shape(shape, origins, directions)","category":"page"},{"location":"tutorial/#Performance-Tips","page":"Tutorial","title":"Performance Tips","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use StaticArrays: All vector operations use SVector for performance\nBatch operations: Process multiple rays together using vector/matrix interfaces:\nintersect_ray_shape(rays::Vector{Ray}, shape) for ray collections\nintersect_ray_shape(rays::Matrix{Ray}, shape) preserves grid structure\nintersect_ray_shape(shape, origins, directions) for maximum performance\nBVH acceleration: Must be pre-built using build_bvh!(shape) or with_bvh=true when loading a shape model\nScale appropriately: Use consistent units (typically meters)\nPrecompute visibility: Use with_face_visibility=true when loading if you need visibility analysis\nAccess patterns: The face visibility graph uses CSR format - sequential access is faster than random","category":"page"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See the API Reference pages for detailed function documentation\nCheck the test suite for more examples\nExplore integration with SPICE.jl for ephemeris data","category":"page"}]
}
