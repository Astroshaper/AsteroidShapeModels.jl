var documenterSearchIndex = {"docs":
[{"location":"api/io/#I/O-Functions","page":"I/O Functions","title":"I/O Functions","text":"","category":"section"},{"location":"api/io/#Loading-Shape-Models","page":"I/O Functions","title":"Loading Shape Models","text":"","category":"section"},{"location":"api/io/#AsteroidShapeModels.load_shape_obj","page":"I/O Functions","title":"AsteroidShapeModels.load_shape_obj","text":"load_shape_obj(shapepath; scale=1.0, with_face_visibility=false, with_bvh=false) -> ShapeModel\n\nLoad a shape model from a Wavefront OBJ file.\n\nArguments\n\nshapepath::String: Path to a Wavefront OBJ file\n\nKeyword Arguments\n\nscale::Real=1.0: Scale factor of the shape model\nwith_face_visibility::Bool=false: Whether to compute face-to-face visibility\nwith_bvh::Bool=false: Whether to build BVH for accelerated ray tracing (experimental)\n\nReturns\n\nShapeModel: Loaded shape model with computed geometric properties\n\nExamples\n\n# Load a shape model\nshape = load_shape_obj(\"asteroid.obj\")\n\n# Load with scaling and visibility computation\nshape = load_shape_obj(\"asteroid_km.obj\", scale=1000, with_face_visibility=true)\n\n# Load with BVH acceleration (experimental)\nshape = load_shape_obj(\"asteroid.obj\"; with_bvh=true)\n\nSee also: load_shape_grid, load_obj\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.load_obj","page":"I/O Functions","title":"AsteroidShapeModels.load_obj","text":"load_obj(shapepath::String; scale=1) -> nodes, faces\n\nLoad a 3D shape model from an OBJ file.\n\nArguments\n\nshapepath::String: Path to the OBJ file\n\nKeyword Arguments\n\nscale::Real=1: Scale factor to apply to all vertex coordinates. For example, use scale=1000 to convert from kilometers to meters\n\nReturns\n\nnodes::Vector{SVector{3,Float64}}: Array of vertex positions\nfaces::Vector{SVector{3,Int64}}: Array of triangular face definitions (1-indexed vertex indices)\n\nExamples\n\n# Load shape model in meters\nnodes, faces = load_obj(\"asteroid.obj\")\n\n# Load shape model and convert from km to m\nnodes, faces = load_obj(\"asteroid_km.obj\", scale=1000)\n\n# Get the number of nodes and faces\nprintln(\"Number of nodes: \", length(nodes))\nprintln(\"Number of faces: \", length(faces))\n\n# Access individual nodes and faces\nfirst_node = nodes[1]  # SVector{3, Float64}\nfirst_face = faces[1]  # SVector{3, Int} with node indices\n\nNotes\n\nThis function uses the FileIO/MeshIO packages to load OBJ files. Only triangular faces are supported.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.isobj","page":"I/O Functions","title":"AsteroidShapeModels.isobj","text":"isobj(filepath::String) -> Bool\n\nCheck if a file has the OBJ file extension.\n\nArguments\n\nfilepath::String: Path to the file to check\n\nReturns\n\nBool: true if the file has .obj extension, false otherwise\n\nExamples\n\nisobj(\"model.obj\")    # Returns true\nisobj(\"model.stl\")    # Returns false\nisobj(\"model.OBJ\")    # Returns false (case-sensitive)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Grid-Loading","page":"I/O Functions","title":"Grid Loading","text":"","category":"section"},{"location":"api/io/#AsteroidShapeModels.load_shape_grid","page":"I/O Functions","title":"AsteroidShapeModels.load_shape_grid","text":"load_shape_grid(xs, ys, zs; scale=1.0, with_face_visibility=false, with_bvh=false) -> ShapeModel\n\nConvert a regular grid (x, y) with z-values to a shape model.\n\nArguments\n\nxs::AbstractVector: x-coordinates of grid points\nys::AbstractVector: y-coordinates of grid points\nzs::AbstractMatrix: z-coordinates of grid points where zs[i,j] corresponds to (xs[i], ys[j])\n\nKeyword Arguments\n\nscale::Real=1.0: Scale factor to apply to all coordinates\nwith_face_visibility::Bool=false: Whether to compute face-to-face visibility\nwith_bvh::Bool=false: Whether to build BVH for accelerated ray tracing (experimental)\n\nReturns\n\nShapeModel: Shape model with computed geometric properties\n\nExamples\n\n# Create a shape from elevation data\nxs = range(-10, 10, length=50)\nys = range(-10, 10, length=50)\nzs = [exp(-(x^2 + y^2)/10) for x in xs, y in ys]  # Gaussian surface\nshape = load_shape_grid(xs, ys, zs)\n\n# With scaling and visibility\nshape = load_shape_grid(xs, ys, zs, scale=1000, with_face_visibility=true)\n\n# With BVH acceleration (experimental)\nshape = load_shape_grid(xs, ys, zs; with_bvh=true)\n\nSee also: load_shape_obj, grid_to_faces\n\n\n\n\n\n","category":"function"},{"location":"api/io/#AsteroidShapeModels.grid_to_faces","page":"I/O Functions","title":"AsteroidShapeModels.grid_to_faces","text":"grid_to_faces(xs::AbstractVector, ys::AbstractVector, zs::AbstractMatrix) -> nodes, faces\n\nConvert a regular grid (x, y) and corresponding z-coordinates to triangular facets.\n\n| ⧹| ⧹| ⧹|\n\nj+1 ・–C–D–・     |⧹ |⧹ |⧹ |     | ⧹| ⧹| ⧹| j   ・–A–B–・     |⧹ |⧹ |⧹ |        i  i+1\n\nArguments\n\nxs::AbstractVector: x-coordinates of grid points (should be sorted)\nys::AbstractVector: y-coordinates of grid points (should be sorted)\nzs::AbstractMatrix: z-coordinates of grid points where zs[i,j] corresponds to (xs[i], ys[j])\n\nReturns\n\nnodes::Vector{SVector{3,Float64}}: Array of 3D vertex positions\nfaces::Vector{SVector{3,Int}}: Array of triangular face definitions (1-indexed)\n\nNotes\n\nEach grid cell is divided into two triangles. The vertices are numbered sequentially row by row (j varies slowest).\n\nExamples\n\n# Create a simple 3x3 grid\nxs = [0.0, 1.0, 2.0]\nys = [0.0, 1.0, 2.0]\nzs = [i + j for i in 1:3, j in 1:3]  # z = x + y\nnodes, faces = grid_to_faces(xs, ys, zs)\n\nSee also: load_shape_grid\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#Visibility-Analysis","page":"Visibility Analysis","title":"Visibility Analysis","text":"","category":"section"},{"location":"api/visibility/#Main-Functions","page":"Visibility Analysis","title":"Main Functions","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.build_face_visibility_graph!","page":"Visibility Analysis","title":"AsteroidShapeModels.build_face_visibility_graph!","text":"build_face_visibility_graph!(shape::ShapeModel)\n\nBuild face-to-face visibility graph for the shape model.\n\nThis function computes which faces are visible from each face and stores the results in a FaceVisibilityGraph structure using CSR (Compressed Sparse Row) format.\n\nArguments\n\nshape : Shape model of an asteroid\n\nAlgorithm\n\nThe implementation uses an optimized non-BVH algorithm with candidate filtering:\n\nPre-filter candidate faces based on normal orientations\nSort candidates by distance for efficient occlusion testing\nCheck visibility between face pairs using ray-triangle intersection\nStore results in memory-efficient CSR format\n\nPerformance Considerations\n\nBVH acceleration was found to be less efficient for face visibility pair searches compared to the optimized candidate filtering approach (slower ~0.5x)\nThe non-BVH implementation with distance-based sorting provides better performance due to the specific nature of face-to-face visibility queries\nDistance-based sorting provides ~2x speedup over naive approaches\n\nNotes\n\nThe visibility graph is stored in shape.face_visibility_graph\nThis is a computationally intensive operation, especially for large models\nThe resulting graph contains view factors, distances, and direction vectors\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.view_factor","page":"Visibility Analysis","title":"AsteroidShapeModels.view_factor","text":"view_factor(cᵢ, cⱼ, n̂ᵢ, n̂ⱼ, aⱼ) -> fᵢⱼ, dᵢⱼ, d̂ᵢⱼ\n\nCalculate the view factor from face i to face j, assuming Lambertian emission.\n\nArguments\n\ncᵢ::StaticVector{3}: Center position of face i\ncⱼ::StaticVector{3}: Center position of face j\nn̂ᵢ::StaticVector{3}: Unit normal vector of face i\nn̂ⱼ::StaticVector{3}: Unit normal vector of face j\naⱼ::Real           : Area of face j\n\nReturns\n\nfᵢⱼ::Real: View factor from face i to face j\ndᵢⱼ::Real: Distance between face centers\nd̂ᵢⱼ::StaticVector{3}: Unit direction vector from face i to face j\n\nNotes\n\nThe view factor is calculated using the formula:\n\nfᵢⱼ = (cosθᵢ * cosθⱼ) / (π * dᵢⱼ²) * aⱼ\n\nwhere θᵢ and θⱼ are the angles between the line connecting the faces and the respective normal vectors.\n\nThe view factor is automatically zero when:\n\nFace i is facing away from face j (cosθᵢ ≤ 0)\nFace j is facing away from face i (cosθⱼ ≤ 0)\nBoth conditions ensure that only mutually visible faces have non-zero view factors\n\nVisual representation\n\n(i)   fᵢⱼ   (j)\n △    -->    △\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#Illumination-Analysis","page":"Visibility Analysis","title":"Illumination Analysis","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.isilluminated","page":"Visibility Analysis","title":"AsteroidShapeModels.isilluminated","text":"isilluminated(shape::ShapeModel, r☉::StaticVector{3}, face_idx::Integer; with_self_shadowing::Bool) -> Bool\n\nCheck if a face is illuminated by the sun.\n\nArguments\n\nshape    : Shape model of an asteroid\nr☉       : Sun's position in the asteroid-fixed frame\nface_idx : Index of the face to be checked\n\nKeyword Arguments\n\nwith_self_shadowing::Bool : Whether to include self-shadowing effects.\nfalse: Use pseudo-convex model (face orientation only)\ntrue: Include self-shadowing (requires face_visibility_graph to be built)\n\nReturns\n\ntrue if the face is illuminated\nfalse if the face is in shadow or facing away from the sun\n\nExamples\n\n# Without self-shadowing (pseudo-convex model)\nilluminated = isilluminated(shape, sun_position, face_idx; with_self_shadowing=false)\n\n# With self-shadowing\nilluminated = isilluminated(shape, sun_position, face_idx; with_self_shadowing=true)\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.update_illumination!","page":"Visibility Analysis","title":"AsteroidShapeModels.update_illumination!","text":"update_illumination!(illuminated::AbstractVector{Bool}, shape::ShapeModel, r☉::StaticVector{3}; with_self_shadowing::Bool)\n\nUpdate illumination state for all faces of a shape model.\n\nArguments\n\nilluminated : Boolean vector to store illumination state (must have length equal to number of faces)\nshape       : Shape model of an asteroid\nr☉          : Sun's position in the asteroid-fixed frame\n\nKeyword Arguments\n\nwith_self_shadowing::Bool : Whether to include self-shadowing effects.\nfalse: Use pseudo-convex model (face orientation only)\ntrue: Include self-shadowing (requires face_visibility_graph to be built)\n\nExamples\n\n# Prepare illumination vector\nilluminated = Vector{Bool}(undef, length(shape.faces))\n\n# Without self-shadowing (pseudo-convex model)\nupdate_illumination!(illuminated, shape, sun_position; with_self_shadowing=false)\n\n# With self-shadowing\nupdate_illumination!(illuminated, shape, sun_position; with_self_shadowing=true)\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.apply_eclipse_shadowing!","page":"Visibility Analysis","title":"AsteroidShapeModels.apply_eclipse_shadowing!","text":"apply_eclipse_shadowing!(\n    illuminated::AbstractVector{Bool}, shape1::ShapeModel, r☉₁::StaticVector{3}, \n    R₁₂::StaticMatrix{3,3}, t₁₂::StaticVector{3}, shape2::ShapeModel\n) -> EclipseStatus\n\nApply eclipse shadowing effects from another shape onto already illuminated faces.\n\nArguments\n\nilluminated : Boolean vector with current illumination state (will be modified)\nshape1      : Target shape model being shadowed (the shape receiving shadows)\nr☉₁         : Sun's position in shape1's frame\nR₁₂         : 3×3 rotation matrix from shape1 frame to shape2 frame\nt₁₂         : 3D translation vector from shape1 frame to shape2 frame\nshape2      : Occluding shape model that may cast shadows on shape1 (must have BVH built via build_bvh!)\n\nReturns\n\nNO_ECLIPSE: No eclipse occurs (bodies are misaligned).\nPARTIAL_ECLIPSE: Some faces that were illuminated are now in shadow by the occluding body.\nTOTAL_ECLIPSE: All faces that were illuminated are now in shadow.\n\nThrows\n\nArgumentError if shape2 does not have BVH built. Call build_bvh!(shape2) before using this function.\n\nDescription\n\nThis function ONLY checks for mutual shadowing (eclipse) effects. It assumes that the illuminated vector already contains the result of face orientation and/or self-shadowing checks. Only faces marked as true in the input will be tested for occlusion by the other body.\n\nThis separation allows flexible control of shadowing effects in thermal modeling:\n\nCall update_illumination_* first for self-shadowing (or face orientation only)\nThen call this function to add mutual shadowing effects\n\nPerformance Optimizations\n\nThe function includes early-out checks at two levels:\n\nBody-level optimizations:\n\nBehind Check: If the occluding body is entirely behind the target relative to the sun, no eclipse can occur.\nLateral Separation Check: If bodies are too far apart laterally (perpendicular to  sun direction), no eclipse can occur.\nTotal Eclipse Check: If the target is completely within the occluding body's shadow, all illuminated faces are set to false without individual ray checks.\n\nFace-level optimizations:\n\nRay-Sphere Intersection Check: For each face, checks if the ray to the sun can possibly intersect the occluding body's bounding sphere. Skips ray-shape test if the ray clearly misses the sphere.\nInscribed Sphere Check: If the ray passes through the occluding body's inscribed sphere, the face is guaranteed to be shadowed, avoiding the expensive ray-shape intersection test.\n\nThese optimizations use maximum_radius and minimum_radius for accurate sphere calculations.\n\nCoordinate Systems\n\nThe transformation from shape1 frame to shape2 frame is given by: p_shape2 = R₁₂ * p_shape1 + t₁₂\n\nExample\n\n# Check self-shadowing first (considering self-shadowing effect)\nupdate_illumination_with_self_shadowing!(illuminated1, shape1, sun_position1)\nupdate_illumination_with_self_shadowing!(illuminated2, shape2, sun_position2)\n\n# Or if you want to ignore self-shadowing:\nupdate_illumination_pseudo_convex!(illuminated1, shape1, sun_position1)\nupdate_illumination_pseudo_convex!(illuminated2, shape2, sun_position2)\n\n# Then check eclipse shadowing\n# For checking mutual shadowing, apply to both shape1 and shape2:\nstatus1 = apply_eclipse_shadowing!(illuminated1, shape1, sun_position1, R12, t12, shape2)\nstatus2 = apply_eclipse_shadowing!(illuminated2, shape2, sun_position2, R21, t21, shape1)\n\n# Handle eclipse status\nif status1 == NO_ECLIPSE\n    println(\"Shape1 is not eclipsed by shape2.\")\nelseif status1 == PARTIAL_ECLIPSE\n    println(\"Shape1 is partially eclipsed by shape2.\")\nelseif status1 == TOTAL_ECLIPSE\n    println(\"Shape1 is totally eclipsed by shape2.\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.EclipseStatus","page":"Visibility Analysis","title":"AsteroidShapeModels.EclipseStatus","text":"EclipseStatus\n\nEnum representing the eclipse status between binary pairs.\n\nValues\n\nNO_ECLIPSE      : No eclipse occurs (bodies are misaligned).\nPARTIAL_ECLIPSE : Some faces are eclipsed by the occluding body.\nTOTAL_ECLIPSE   : All illuminated faces are eclipsed (complete shadow).\n\n\n\n\n\n","category":"type"},{"location":"api/visibility/#FaceVisibilityGraph-Functions","page":"Visibility Analysis","title":"FaceVisibilityGraph Functions","text":"","category":"section"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_indices","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_indices","text":"get_visible_face_indices(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet indices of faces visible from the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_view_factors","page":"Visibility Analysis","title":"AsteroidShapeModels.get_view_factors","text":"get_view_factors(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet view factors for the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_distances","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_distances","text":"get_visible_face_distances(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet distances to visible faces from the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_directions","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_directions","text":"get_visible_face_directions(graph::FaceVisibilityGraph, face_idx::Int) -> SubArray\n\nGet direction vectors to visible faces from the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.get_visible_face_data","page":"Visibility Analysis","title":"AsteroidShapeModels.get_visible_face_data","text":"get_visible_face_data(graph::FaceVisibilityGraph, face_idx::Int, idx::Int)\n\nGet the idx-th visible face data for the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/visibility/#AsteroidShapeModels.num_visible_faces","page":"Visibility Analysis","title":"AsteroidShapeModels.num_visible_faces","text":"num_visible_faces(graph::FaceVisibilityGraph, face_idx::Int) -> Int\n\nGet the number of visible faces for the specified face.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Core-Types","page":"Types","title":"Core Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.ShapeModel","page":"Types","title":"AsteroidShapeModels.ShapeModel","text":"ShapeModel\n\nA polyhedral shape model of an asteroid.\n\nFields\n\nnodes                 : Vector of node positions\nfaces                 : Vector of vertex indices of faces\nface_centers          : Center position of each face\nface_normals          : Normal vector of each face\nface_areas            : Area of of each face\nface_visibility_graph : FaceVisibilityGraph for efficient visibility queries\nbvh                   : Bounding Volume Hierarchy for accelerated ray tracing\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.Ray","page":"Types","title":"AsteroidShapeModels.Ray","text":"Ray\n\nStructure representing a ray in 3D space.\n\nFields\n\norigin    : Ray origin point\ndirection : Ray direction vector (normalized)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Result-Types","page":"Types","title":"Result Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.RayTriangleIntersectionResult","page":"Types","title":"AsteroidShapeModels.RayTriangleIntersectionResult","text":"RayTriangleIntersectionResult\n\nStructure representing the result of ray-triangle intersection test.\n\nFields\n\nhit      : true if intersection exists, false otherwise\ndistance : Distance from ray origin to intersection point\npoint    : Coordinates of the intersection point\n\n\n\n\n\n","category":"type"},{"location":"api/types/#AsteroidShapeModels.RayShapeIntersectionResult","page":"Types","title":"AsteroidShapeModels.RayShapeIntersectionResult","text":"RayShapeIntersectionResult\n\nStructure representing the result of ray-shape intersection test.\n\nFields\n\nhit      : true if intersection exists, false otherwise\ndistance : Distance from ray origin to intersection point\npoint    : Coordinates of the intersection point\nface_idx : Index of the intersected face\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Face-Face-Visibility-Types","page":"Types","title":"Face-Face Visibility Types","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.FaceVisibilityGraph","page":"Types","title":"AsteroidShapeModels.FaceVisibilityGraph","text":"FaceVisibilityGraph\n\nEfficient visible face graph structure using CSR (Compressed Sparse Row) format. Provides better memory efficiency and cache locality compared to adjacency list format.\n\nFields\n\nrow_ptr: Start index of visible face data for each face (length: nfaces + 1)\ncol_idx: Indices of visible faces (column indices in CSR format)\nview_factors: View factors for each visible face pair\ndistances: Distances between each visible face pair\ndirections: Unit direction vectors between each visible face pair\nnfaces: Total number of faces\nnnz: Number of non-zero elements (total number of visible face pairs)\n\nExample\n\nIf face 1 is visible to faces 2,3 and face 2 is visible to faces 1,3,4:\n\nrow_ptr = [1, 3, 6, 7]\ncol_idx = [2, 3, 1, 3, 4, ...]\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Functions-to-accelerate-ray-tracing","page":"Types","title":"Functions to accelerate ray tracing","text":"","category":"section"},{"location":"api/types/#AsteroidShapeModels.build_bvh!","page":"Types","title":"AsteroidShapeModels.build_bvh!","text":"build_bvh!(shape::ShapeModel)\n\nBuild a Bounding Volume Hierarchy (BVH) for the shape model to accelerate ray tracing. The BVH is stored in the shape.bvh field.\n\nArguments\n\nshape: The shape model to build the BVH for\n\nNotes\n\nThis function creates bounding boxes for each triangular face and constructs an implicit BVH tree structure for efficient ray-shape intersection queries.\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Geometric-Operations","page":"Geometric Operations","title":"Geometric Operations","text":"","category":"section"},{"location":"api/geometry/#Face-Properties","page":"Geometric Operations","title":"Face Properties","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.face_center","page":"Geometric Operations","title":"AsteroidShapeModels.face_center","text":"face_center(vs::StaticVector{3, <:StaticVector{3}}) -> StaticVector{3}\nface_center(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> StaticVector{3}\n\nCalculate the center (centroid) of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle\n\nReturns\n\nStaticVector{3}: The center point of the triangle, computed as the arithmetic mean of the three vertices\n\nExamples\n\nv1 = SA[1.0, 0.0, 0.0]\nv2 = SA[0.0, 1.0, 0.0]\nv3 = SA[0.0, 0.0, 1.0]\ncenter = face_center(v1, v2, v3)  # Returns SA[1/3, 1/3, 1/3]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.face_normal","page":"Geometric Operations","title":"AsteroidShapeModels.face_normal","text":"face_normal(vs::StaticVector{3, <:StaticVector{3}}) -> StaticVector{3}\nface_normal(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> StaticVector{3}\n\nCalculate the unit normal vector of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle in counter-clockwise order\n\nReturns\n\nStaticVector{3}: The unit normal vector pointing outward from the face (following right-hand rule)\n\nNotes\n\nThe normal direction follows the right-hand rule based on the vertex ordering. For a counter-clockwise vertex ordering when viewed from outside, the normal points outward.\n\nExamples\n\nv1 = SA[1.0, 0.0, 0.0]\nv2 = SA[0.0, 1.0, 0.0]\nv3 = SA[0.0, 0.0, 0.0]\nnormal = face_normal(v1, v2, v3)  # Returns SA[0.0, 0.0, 1.0]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.face_area","page":"Geometric Operations","title":"AsteroidShapeModels.face_area","text":"face_area(vs::StaticVector{3, <:StaticVector{3}}) -> Real\nface_area(v1::StaticVector{3}, v2::StaticVector{3}, v3::StaticVector{3}) -> Real\n\nCalculate the area of a triangular face.\n\nArguments\n\nvs: A static vector containing three vertices of the triangle\nv1, v2, v3: Three vertices of the triangle\n\nReturns\n\nReal: The area of the triangle\n\nNotes\n\nThe area is computed using the cross product formula: area = ||(v2 - v1) × (v3 - v2)|| / 2\n\nExamples\n\n# Unit right triangle\nv1 = SA[0.0, 0.0, 0.0]\nv2 = SA[1.0, 0.0, 0.0]\nv3 = SA[0.0, 1.0, 0.0]\narea = face_area(v1, v2, v3)  # Returns 0.5\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.get_face_nodes","page":"Geometric Operations","title":"AsteroidShapeModels.get_face_nodes","text":"get_face_nodes(nodes, faces, face_idx) -> (v1, v2, v3)\n\nExtract three nodes of a triangular face from node and face arrays.\n\nArguments\n\nnodes: Array of node positions\nfaces: Array of face definitions (each face is an array of 3 node indices)\nface_idx: Index of the face to extract nodes from (1-based)\n\nReturns\n\nTuple of three nodes (v1, v2, v3)\n\nExamples\n\nnodes = [SA[0.0, 0.0, 0.0], SA[1.0, 0.0, 0.0], SA[0.0, 1.0, 0.0]]\nfaces = [SA[1, 2, 3]]\nv1, v2, v3 = get_face_nodes(nodes, faces, 1)\n\n\n\n\n\nget_face_nodes(shape::ShapeModel, face_idx::Integer) -> (v1, v2, v3)\n\nExtract three nodes of a triangular face from a shape model.\n\nArguments\n\nshape    : Shape model containing nodes and faces\nface_idx : Index of the face in the shape model\n\nReturns\n\nTuple of three nodes (v1, v2, v3)\n\nExamples\n\n# Assuming shape is a loaded ShapeModel\nv1, v2, v3 = get_face_nodes(shape, 1)  # Get nodes of the first face\n\nSee also: get_face_nodes(nodes, faces, face_idx)\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Shape-Properties","page":"Geometric Operations","title":"Shape Properties","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.polyhedron_volume","page":"Geometric Operations","title":"AsteroidShapeModels.polyhedron_volume","text":"polyhedron_volume(nodes, faces) -> Float64\npolyhedron_volume(shape::ShapeModel) -> Float64\n\nCalculate the volume of a polyhedron using the divergence theorem.\n\nArguments\n\nnodes: Array of vertex positions\nfaces: Array of triangular face definitions (vertex indices)\nshape::ShapeModel: A shape model containing nodes and faces\n\nReturns\n\nFloat64: Volume of the polyhedron\n\nNotes\n\nThe volume is computed using the formula: V = (1/6) * Σ (A × B) · C where A, B, C are the vertices of each triangular face. The shape must be a closed polyhedron with consistently oriented faces.\n\nExamples\n\n# Unit cube\nnodes = [SA[0,0,0], SA[1,0,0], SA[1,1,0], SA[0,1,0],\n         SA[0,0,1], SA[1,0,1], SA[1,1,1], SA[0,1,1]]\nfaces = [SA[1,2,3], SA[1,3,4], ...]  # Define all 12 triangular faces\nvol = polyhedron_volume(nodes, faces)  # Returns 1.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.equivalent_radius","page":"Geometric Operations","title":"AsteroidShapeModels.equivalent_radius","text":"equivalent_radius(VOLUME::Real) -> Float64\nequivalent_radius(shape::ShapeModel) -> Float64\n\nCalculate the radius of a sphere with the same volume as the given volume or shape.\n\nArguments\n\nVOLUME::Real: Volume of the object\nshape::ShapeModel: A shape model to calculate volume from\n\nReturns\n\nFloat64: Radius of the equivalent sphere\n\nNotes\n\nThe equivalent radius is calculated as: r = (3V/4π)^(1/3)\n\nExamples\n\n# Sphere with radius 2\nvolume = 4π/3 * 2^3\nr_eq = equivalent_radius(volume)  # Returns 2.0\n\n# From shape model\nshape = load_shape_obj(\"asteroid.obj\")\nr_eq = equivalent_radius(shape)\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.maximum_radius","page":"Geometric Operations","title":"AsteroidShapeModels.maximum_radius","text":"maximum_radius(nodes) -> Float64\nmaximum_radius(shape::ShapeModel) -> Float64\n\nCalculate the maximum distance from the origin to any vertex.\n\nArguments\n\nnodes: Array of vertex positions\nshape::ShapeModel: A shape model containing nodes\n\nReturns\n\nFloat64: Maximum distance from origin to any vertex\n\nNotes\n\nThis represents the radius of the smallest sphere centered at the origin that contains all vertices of the shape.\n\nExamples\n\nnodes = [SA[1,0,0], SA[0,2,0], SA[0,0,3]]\nr_max = maximum_radius(nodes)  # Returns 3.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.minimum_radius","page":"Geometric Operations","title":"AsteroidShapeModels.minimum_radius","text":"minimum_radius(nodes) -> Float64\nminimum_radius(shape::ShapeModel) -> Float64\n\nCalculate the minimum distance from the origin to any vertex.\n\nArguments\n\nnodes: Array of vertex positions\nshape::ShapeModel: A shape model containing nodes\n\nReturns\n\nFloat64: Minimum distance from origin to any vertex\n\nNotes\n\nThis represents the radius of the largest sphere centered at the origin that fits entirely inside the convex hull of the vertices.\n\nExamples\n\nnodes = [SA[1,0,0], SA[0,2,0], SA[0,0,3]]\nr_min = minimum_radius(nodes)  # Returns 1.0\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#Angle-Calculations","page":"Geometric Operations","title":"Angle Calculations","text":"","category":"section"},{"location":"api/geometry/#AsteroidShapeModels.angle_rad","page":"Geometric Operations","title":"AsteroidShapeModels.angle_rad","text":"angle_rad(v1, v2) -> Float64\n\nCalculate the angle between two vectors in radians.\n\nArguments\n\nv1 : First vector\nv2 : Second vector\n\nReturns\n\nAngle between vectors in radians [0, π]\n\n\n\n\n\nangle_rad(v1::AbstractVector{<:AbstractVector}, v2::AbstractVector{<:AbstractVector}) -> Vector{Float64}\n\nCalculate angles between corresponding pairs of vectors in two arrays (broadcast version).\n\nArguments\n\nv1: Array of first vectors\nv2: Array of second vectors (must have same length as v1)\n\nReturns\n\nArray of angles in radians between corresponding vector pairs\n\nExamples\n\nv1s = [SA[1,0,0], SA[0,1,0]]\nv2s = [SA[0,1,0], SA[1,0,0]]\nangles = angle_rad(v1s, v2s)  # Returns [π/2, π/2]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.angle_deg","page":"Geometric Operations","title":"AsteroidShapeModels.angle_deg","text":"angle_deg(v1, v2) -> Float64\n\nCalculate the angle between two vectors in degrees.\n\nArguments\n\nv1 : First vector\nv2 : Second vector\n\nReturns\n\nAngle between vectors in degrees [0, 180]\n\n\n\n\n\nangle_deg(v1::AbstractVector{<:AbstractVector}, v2::AbstractVector{<:AbstractVector}) -> Vector{Float64}\n\nCalculate angles between corresponding pairs of vectors in two arrays (broadcast version).\n\nArguments\n\nv1: Array of first vectors\nv2: Array of second vectors (must have same length as v1)\n\nReturns\n\nArray of angles in degrees between corresponding vector pairs\n\nExamples\n\nv1s = [SA[1,0,0], SA[0,1,0]]\nv2s = [SA[0,1,0], SA[1,0,0]]\nangles = angle_deg(v1s, v2s)  # Returns [90.0, 90.0]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.solar_phase_angle","page":"Geometric Operations","title":"AsteroidShapeModels.solar_phase_angle","text":"solar_phase_angle(sun, target, observer) -> Float64\n\nCalculate a sun-target-observer angle (phase angle).\n\nArguments\n\nsun      : Sun position vector\ntarget   : Target position vector\nobserver : Observer position vector\n\nReturns\n\n∠STO : Sun-target-observer angle (phase angle) [rad]\n\n\n\n\n\n","category":"function"},{"location":"api/geometry/#AsteroidShapeModels.solar_elongation_angle","page":"Geometric Operations","title":"AsteroidShapeModels.solar_elongation_angle","text":"solar_elongation_angle(sun, observer, target) -> Float64\n\nCalculate a sun-observer-target angle (solar elongation angle).\n\nArguments\n\nsun      : Sun position vector\nobserver : Observer position vector\ntarget   : Target position vector\n\nReturns\n\n∠SOT : Sun-observer-target angle (solar elongation angle) [rad]\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#Ray-Intersection","page":"Ray Intersection","title":"Ray Intersection","text":"","category":"section"},{"location":"api/raycast/#High-Level-Functions","page":"Ray Intersection","title":"High-Level Functions","text":"","category":"section"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_shape","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_shape","text":"intersect_ray_shape(shape::ShapeModel, origins::AbstractMatrix{<:Real}, directions::AbstractMatrix{<:Real}) -> Vector{RayShapeIntersectionResult}\n\nPerform batch ray-shape intersection tests using the same interface as ImplicitBVH.traverse_rays.\n\nThis is the core implementation that all other intersect_ray_shape methods delegate to.\n\nArguments\n\nshape      : Shape model (must have BVH built via build_bvh!)\norigins    : 3×N matrix where each column is a ray origin\ndirections : 3×N matrix where each column is a ray direction\n\nReturns\n\nVector of RayShapeIntersectionResult objects, one for each input ray\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nNotes\n\nThis function provides a convenient interface that matches ImplicitBVH.traverse_rays parameters\nBVH must be pre-built using build_bvh!(shape) or by creating the shape with with_bvh=true\nAll rays are processed in a single batch for efficiency\n\nExample\n\n# Create ray data\nn_rays = 100\norigins = rand(3, n_rays) .* 1000  # Random origins\ndirections = normalize.(eachcol(rand(3, n_rays) .- 0.5))  # Random directions\n\n# Convert directions back to matrix\ndirections = hcat(directions...)\n\n# Perform batch intersection\nresults = intersect_ray_shape(shape, origins, directions)\n\n\n\n\n\nintersect_ray_shape(ray::Ray, shape::ShapeModel) -> RayShapeIntersectionResult\n\nPerform ray-shape intersection test using BVH acceleration. Uses the Möller–Trumbore algorithm for ray-triangle mesh intersection.\n\nArguments\n\nray   : Ray with origin and direction\nshape : Shape model (must have BVH built via build_bvh!)\n\nReturns\n\nRayShapeIntersectionResult object containing the intersection test result\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nNotes\n\nBVH must be pre-built using build_bvh!(shape) or by creating the shape with with_bvh=true\nTo pre-build BVH, use load_shape_obj(\"path/to/shape.obj\"; with_bvh=true)\nOr for an existing ShapeModel: build_bvh!(shape)\n\nExample\n\nray = Ray(SA[0.0, 0.0, 1000.0], SA[0.0, 0.0, -1.0])\nresult = intersect_ray_shape(ray, shape)\n\nif result.hit\n    println(\"Hit face $(result.face_idx) at distance $(result.distance)\")\nend\n\n\n\n\n\nintersect_ray_shape(rays::AbstractVector{Ray}, shape::ShapeModel) -> Vector{RayShapeIntersectionResult}\n\nPerform batch ray-shape intersection tests for multiple rays.\n\nArguments\n\nrays  : Vector of Ray objects\nshape : Shape model (must have BVH built via build_bvh!)\n\nReturns\n\nVector of RayShapeIntersectionResult objects, one for each input ray\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nExample\n\n# Create a vector of rays\nrays = [Ray(SA[x, 0.0, 1000.0], SA[0.0, 0.0, -1.0]) for x in -500:100:500]\nresults = intersect_ray_shape(rays, shape)\n\n# Count hits\nn_hits = count(r -> r.hit, results)\nprintln(\"$n_hits out of $(length(rays)) rays hit the shape\")\n\n\n\n\n\nintersect_ray_shape(rays::AbstractMatrix{Ray}, shape::ShapeModel) -> Matrix{RayShapeIntersectionResult}\n\nPerform batch ray-shape intersection tests for a matrix of rays. The output shape matches the input shape, preserving spatial arrangement.\n\nArguments\n\nrays  : Matrix of Ray objects\nshape : Shape model (must have BVH built via build_bvh!)\n\nReturns\n\nMatrix of RayShapeIntersectionResult objects with the same size as input\n\nThrows\n\nArgumentError if BVH is not built. Call build_bvh!(shape) before using this function.\n\nExample\n\n# Create a matrix of rays\nrays = [Ray(SA[x, y, 1000.0], SA[0.0, 0.0, -1.0]) for x in -500:100:500, y in -500:100:500]\nresults = intersect_ray_shape(rays, shape)\n\n# Process results while preserving grid structure\nfor i in 1:size(results, 1), j in 1:size(results, 2)\n    if results[i, j].hit\n        println(\"Ray at ($i, $j) hit at $(results[i, j].point)\")\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/raycast/#Low-Level-Functions","page":"Ray Intersection","title":"Low-Level Functions","text":"","category":"section"},{"location":"api/raycast/#AsteroidShapeModels.intersect_ray_triangle","page":"Ray Intersection","title":"AsteroidShapeModels.intersect_ray_triangle","text":"intersect_ray_triangle(ray::Ray, v1::AbstractVector{<:Real}, v2::AbstractVector{<:Real}, v3::AbstractVector{<:Real}) -> RayTriangleIntersectionResult\n\nPerform ray-triangle intersection test using the Möller–Trumbore algorithm.\n\nArguments\n\nray: Ray with origin and direction\nv1: Triangle vertex 1\nv2: Triangle vertex 2\nv3: Triangle vertex 3\n\nReturns\n\nRayTriangleIntersectionResult object containing the intersection test result\n\nAlgorithm Details\n\nThis implementation has the following characteristics:\n\nNo backface culling: Triangles are hit from both sides (front and back)\nForward rays only: Only intersections in the ray direction are detected (distance > 0)\nNo self-intersection: Rays starting exactly on the triangle surface typically miss due to numerical precision\n\nExample\n\n# Ray from above hits triangle on XY plane\nray = Ray(SA[0.5, 0.5, 1.0], SA[0.0, 0.0, -1.0])\nv1, v2, v3 = SA[0.0, 0.0, 0.0], SA[1.0, 0.0, 0.0], SA[0.0, 1.0, 0.0]\nresult = intersect_ray_triangle(ray, v1, v2, v3)\n# result.hit == true, result.distance ≈ 1.0\n\n# Ray from below also hits (no backface culling)\nray_below = Ray(SA[0.5, 0.5, -1.0], SA[0.0, 0.0, 1.0])\nresult = intersect_ray_triangle(ray_below, v1, v2, v3)\n# result.hit == true\n\n# Ray pointing away misses (backward intersection rejected)\nray_away = Ray(SA[0.5, 0.5, 1.0], SA[0.0, 0.0, 1.0])\nresult = intersect_ray_triangle(ray_away, v1, v2, v3)\n# result.hit == false\n\n\n\n\n\nintersect_ray_triangle(ray::Ray, shape::ShapeModel, face_idx::Integer) -> RayTriangleIntersectionResult\n\nPerform ray-triangle intersection test for a specific face in a shape model.\n\nArguments\n\nray      : Ray with origin and direction\nshape    : Shape model containing the triangle\nface_idx : Index of the face to test (1-based)\n\nReturns\n\nRayTriangleIntersectionResult object containing the intersection test result\n\nAlgorithm Details\n\nThis function uses the same Möller-Trumbore algorithm as the base implementation:\n\nNo backface culling (triangles are hit from both sides)\nForward rays only (distance > 0)\nInlined for performance\n\nExample\n\nshape = load_shape_obj(\"asteroid.obj\")\nray = Ray(SA[0.0, 0.0, 100.0], SA[0.0, 0.0, -1.0])\nresult = intersect_ray_triangle(ray, shape, 1)  # Test first face\n\n\n\n\n\nintersect_ray_triangle(ray::Ray, nodes::AbstractVector, faces::AbstractVector, face_idx::Integer) -> RayTriangleIntersectionResult\n\nPerform ray-triangle intersection test for a specific face given nodes and faces arrays.\n\nArguments\n\nray      : Ray with origin and direction\nnodes    : Array of node positions (3D vectors)\nfaces    : Array of face definitions (each face is an array of 3 node indices)\nface_idx : Index of the face to test (1-based)\n\nReturns\n\nRayTriangleIntersectionResult object containing the intersection test result\n\nAlgorithm Details\n\nThis function uses the same Möller-Trumbore algorithm as the base implementation:\n\nNo backface culling (triangles are hit from both sides)\nForward rays only (distance > 0)\nInlined for performance\n\nNotes\n\nThis is a lower-level interface useful when working directly with node and face arrays without a full ShapeModel structure.\n\n\n\n\n\n","category":"function"},{"location":"guides/bvh_usage/#BVH-(Bounding-Volume-Hierarchy)-Usage-Guide","page":"BVH Usage","title":"BVH (Bounding Volume Hierarchy) Usage Guide","text":"","category":"section"},{"location":"guides/bvh_usage/#Overview","page":"BVH Usage","title":"Overview","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"AsteroidShapeModels.jl uses BVH (Bounding Volume Hierarchy) acceleration structures to optimize ray-shape intersection operations. The BVH implementation is provided by the ImplicitBVH.jl package and is automatically utilized for optimal performance.","category":"page"},{"location":"guides/bvh_usage/#How-BVH-is-Used","page":"BVH Usage","title":"How BVH is Used","text":"","category":"section"},{"location":"guides/bvh_usage/#Fixed-Optimal-Implementations","page":"BVH Usage","title":"Fixed Optimal Implementations","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Each operation in the package uses a fixed implementation that has been determined to be optimal through benchmarking:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Ray-shape intersection: Uses BVH implementation (~50x speedup over naive approach)\nFace visibility graph: Uses non-BVH algorithm with candidate filtering (2x faster than BVH)\nIllumination checks: Uses non-BVH implementation with precomputed visibility graph","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"These implementations are not user-configurable - the package uses the proven fastest approach for each operation.","category":"page"},{"location":"guides/bvh_usage/#When-to-Use-with_bvhtrue","page":"BVH Usage","title":"When to Use with_bvh=true","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"The with_bvh parameter in load_shape_obj controls whether the BVH is built during model loading:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"# Build BVH during loading (recommended for ray tracing applications)\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_bvh=true)\n\n# Load without BVH (BVH will be built on first ray intersection)\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_bvh=false)\n# or simply omit the parameter (default is `with_bvh=false`):\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000)","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Use with_bvh=true when:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"You plan to perform many ray intersections\nYou want predictable performance (avoid first-call overhead)\nYou're building a ray tracing application","category":"page"},{"location":"guides/bvh_usage/#Manual-BVH-Construction","page":"BVH Usage","title":"Manual BVH Construction","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"You can also build the BVH manually after loading:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"shape = load_shape_obj(\"asteroid.obj\"; scale=1000)\nbuild_bvh!(shape)  # Build BVH in-place","category":"page"},{"location":"guides/bvh_usage/#Performance-Characteristics","page":"BVH Usage","title":"Performance Characteristics","text":"","category":"section"},{"location":"guides/bvh_usage/#Ray-Intersection-Performance","page":"BVH Usage","title":"Ray Intersection Performance","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"With BVH acceleration:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Single ray: ~3-5 μs per intersection (for 50k face models)\nComplexity: O(log n) where n is the number of faces\nMemory overhead: ~100-200 bytes per face","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Without BVH (first call only):","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Additional overhead for BVH construction\nSubsequent calls use the cached BVH","category":"page"},{"location":"guides/bvh_usage/#Batch-Processing","page":"BVH Usage","title":"Batch Processing","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"For multiple rays, use batch processing for optimal performance:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"# Process multiple rays efficiently\nrays = [Ray(origin, direction) for ...]\n\n# Vector of rays - returns vector of results\nresults = intersect_ray_shape(rays, shape)\n\n# Matrix of rays - preserves grid structure\nray_grid = [Ray(...) for x in 1:nx, y in 1:ny]\nresult_grid = intersect_ray_shape(ray_grid, shape)\n\n# Raw arrays for maximum performance\norigins    = zeros(3, n_rays)  # Each column is a ray origin\ndirections = zeros(3, n_rays)  # Each column is a ray direction\n# ... fill arrays ...\nresults = intersect_ray_shape(shape, origins, directions)","category":"page"},{"location":"guides/bvh_usage/#Implementation-Details","page":"BVH Usage","title":"Implementation Details","text":"","category":"section"},{"location":"guides/bvh_usage/#Why-Different-Algorithms-for-Different-Operations?","page":"BVH Usage","title":"Why Different Algorithms for Different Operations?","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Ray intersection: BVH excels at single ray queries by quickly eliminating non-intersecting faces\nFace visibility: Non-BVH algorithm with candidate filtering is more efficient because:\nIt processes many face pairs simultaneously\nDistance-based sorting provides natural occlusion culling\nThe specific geometry of face-to-face visibility favors this approach\nIllumination: Leverages precomputed visibility graph for O(1) lookup of potentially occluding faces","category":"page"},{"location":"guides/bvh_usage/#Memory-Considerations","page":"BVH Usage","title":"Memory Considerations","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"The BVH structure requires additional memory:","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Tree nodes: ~32 bytes per face\nBounding boxes: ~24 bytes per face\nTotal overhead: ~100-200 bytes per face (depending on tree depth)","category":"page"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"For a 50k face model, expect ~5-10 MB additional memory usage.","category":"page"},{"location":"guides/bvh_usage/#Example:-Ray-Tracing-Application","page":"BVH Usage","title":"Example: Ray Tracing Application","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"using AsteroidShapeModels\nusing StaticArrays\n\n# Load model with BVH for ray tracing\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_bvh=true)\n\n# Camera rays for rendering\nfunction render_image(shape, camera_pos, camera_dir, width, height)\n    rays = Matrix{Ray}(undef, height, width)\n    \n    # Generate camera rays\n    for y in 1:height, x in 1:width\n        # ... compute ray direction ...\n        rays[y, x] = Ray(camera_pos, ray_dir)\n    end\n    \n    # Batch process all rays\n    intersections = intersect_ray_shape(rays, shape)\n    \n    # Process results\n    image = zeros(height, width)\n    for y in 1:height, x in 1:width\n        if intersections[y, x].hit\n            # Compute shading, distance, etc.\n            image[y, x] = compute_pixel_value(intersections[y, x])\n        end\n    end\n    \n    return image\nend","category":"page"},{"location":"guides/bvh_usage/#Best-Practices","page":"BVH Usage","title":"Best Practices","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"Preload BVH for ray tracing applications using with_bvh=true\nUse batch processing when intersecting multiple rays\nLet the package choose the optimal algorithm for each operation\nMonitor memory usage for very large models (>1M faces)","category":"page"},{"location":"guides/bvh_usage/#See-Also","page":"BVH Usage","title":"See Also","text":"","category":"section"},{"location":"guides/bvh_usage/","page":"BVH Usage","title":"BVH Usage","text":"intersect_ray_shape - Ray-shape intersection function\nbuild_bvh! - Manual BVH construction\nPerformance Tips - General optimization guidelines","category":"page"},{"location":"api/roughness/#Surface-Roughness","page":"Surface Roughness","title":"Surface Roughness","text":"","category":"section"},{"location":"api/roughness/#Crater-Modeling","page":"Surface Roughness","title":"Crater Modeling","text":"","category":"section"},{"location":"api/roughness/#AsteroidShapeModels.crater_curvature_radius","page":"Surface Roughness","title":"AsteroidShapeModels.crater_curvature_radius","text":"crater_curvature_radius(r, h) -> R\n\nReturn the curvature radius of a concave spherical segment.\n\nArguments\n\nr: Crater radius\nh: Crater depth\n\n\n\n\n\n","category":"function"},{"location":"api/roughness/#AsteroidShapeModels.concave_spherical_segment","page":"Surface Roughness","title":"AsteroidShapeModels.concave_spherical_segment","text":"concave_spherical_segment(r, h, xc, yc, x, y) -> z\n\nReturn the z-coordinate of a concave spherical segment.\n\nArguments\n\nr : Crater radius\nh : Crater depth\nxc: x-coordinate of crater center\nyc: y-coordinate of crater center\nx : x-coordinate where to calculate z\ny : y-coordinate where to calculate z\n\n\n\n\n\nconcave_spherical_segment(r, h; Nx=2^5, Ny=2^5, xc=0.5, yc=0.5) -> xs, ys, zs\n\nReturn (x, y, z) grid of a concave spherical segment.\n\nArguments\n\nr : Crater radius\nh : Crater depth\nNx: Number of nodes in the x-direction\nNy: Number of nodes in the y-direction\nxc: x-coordinate of crater center\nyc: y-coordinate of crater center\n\n\n\n\n\n","category":"function"},{"location":"#AsteroidShapeModels.jl","page":"Home","title":"AsteroidShapeModels.jl","text":"","category":"section"},{"location":"#AsteroidShapeModels.AsteroidShapeModels","page":"Home","title":"AsteroidShapeModels.AsteroidShapeModels","text":"AsteroidShapeModels\n\nA Julia package for geometric processing and analysis of asteroid shape models.\n\nThis package provides comprehensive tools for working with polyhedral shape models of asteroids, including loading from OBJ files, computing geometric properties, ray-shape intersection, visibility analysis, and surface roughness modeling.\n\nMain Types\n\nShapeModel: Core data structure for polyhedral shapes\nRay: Ray for ray casting operations\nFaceVisibilityGraph: CSR-style data structure for face-to-face visibility\n\nKey Functions\n\nShape I/O: load_shape_obj, load_obj, load_shape_grid\nGeometric properties: face_center, face_normal, face_area, polyhedron_volume\nRay intersection: intersect_ray_triangle, intersect_ray_shape\nVisibility: build_face_visibility_graph!, isilluminated, view_factor\nShape analysis: equivalent_radius, maximum_radius, minimum_radius\n\nExample\n\nusing AsteroidShapeModels\n\n# Load an asteroid shape model with face-face visibility\nshape = load_shape_obj(\"path/to/shape.obj\", scale=1000, with_face_visibility=true)  # Convert km to m\n\n# Access to face properties\nshape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face\n\nSee the documentation for detailed usage examples and API reference.\n\n\n\n\n\n","category":"module"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AsteroidShapeModels.jl provides comprehensive tools for working with polyhedral shape models of asteroids. The package supports:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loading shape models from OBJ files\nComputing geometric properties (area, volume, normals)\nRay-shape intersection testing with optional BVH acceleration\nFace-to-face visibility analysis with BVH support\nSurface roughness modeling\nIllumination calculations","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AsteroidShapeModels\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AsteroidShapeModels\n\n# Load an asteroid shape model with face-face visibility\nshape = load_shape_obj(\"path/to/shape.obj\", scale=1000, with_face_visibility=true)  # Convert km to m\n\n# NEW: Load with BVH acceleration for ray tracing\nshape_bvh = load_shape_obj(\"path/to/shape.obj\", scale=1000, with_bvh=true)\n\n# Or build BVH for an existing shape\nbuild_bvh!(shape)\n\n# Access to face properties\nshape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Shape-Model-Management","page":"Home","title":"Shape Model Management","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load polyhedral models from OBJ files\nAutomatic computation of face centers, normals, and areas\nSupport for scaling and coordinate transformations","category":"page"},{"location":"#Geometric-Analysis","page":"Home","title":"Geometric Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Face properties: center, normal, area\nShape properties: volume, equivalent radius\nBounding box computation","category":"page"},{"location":"#Ray-Intersection","page":"Home","title":"Ray Intersection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast ray-triangle intersection using Möller–Trumbore algorithm\nRay-shape intersection with optional BVH acceleration (~50x speedup)\nBounding box culling for efficiency","category":"page"},{"location":"#Visibility-Analysis","page":"Home","title":"Visibility Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Face-to-face visibility computation with optimized non-BVH algorithm\nView factor calculations for thermal modeling\nIllumination determination with configurable self-shadowing\nBatch illumination updates for all faces\nBinary asteroid mutual shadowing and eclipse detection","category":"page"},{"location":"#Surface-Roughness","page":"Home","title":"Surface Roughness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Crater modeling\nSurface curvature analysis","category":"page"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"types.jl - Core data structures and type definitions\nobj_io.jl - OBJ file loading and parsing\nface_properties.jl - Face geometric computations (center, normal, area)\nshape_operations.jl - Shape-level operations (volume, radius calculations)\nray_intersection.jl - Ray casting and intersection algorithms\nvisibility.jl - Face-to-face visibility and illumination analysis\ngeometry_utils.jl - Geometric helper functions and angle calculations\nroughness.jl - Surface roughness and crater modeling","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates the main features of AsteroidShapeModels.jl through practical examples.","category":"page"},{"location":"tutorial/#Loading-a-Shape-Model","page":"Tutorial","title":"Loading a Shape Model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using AsteroidShapeModels\nusing StaticArrays\n\n# Load from OBJ file\nshape = load_shape_obj(\"path/to/shape.obj\")\n\n# Load with scaling (e.g., converting km to m)\nshape_m = load_shape_obj(\"path/to/shape.obj\"; scale=1000)\n\n# Access shape properties\nprintln(\"Number of nodes : $(length(shape.nodes))\")\nprintln(\"Number of faces : $(length(shape.faces))\")","category":"page"},{"location":"tutorial/#Working-with-Face-Properties","page":"Tutorial","title":"Working with Face Properties","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"shape.face_centers  # Center position of each face\nshape.face_normals  # Normal vector of each face\nshape.face_areas    # Area of of each face\n\n# Get properties of face 1\nshape.face_centers[1]  # Center position of each face\nshape.face_normals[1]  # Normal vector of each face\nshape.face_areas[1]    # Area of of each face","category":"page"},{"location":"tutorial/#Shape-Analysis","page":"Tutorial","title":"Shape Analysis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Compute shape properties\nvolume = polyhedron_volume(shape)\neq_radius = equivalent_radius(shape)\nmax_radius = maximum_radius(shape)\nmin_radius = minimum_radius(shape)\n\nprintln(\"Volume            : $volume m³\")\nprintln(\"Equivalent radius : $eq_radius m\")\nprintln(\"Maximum radius    : $max_radius m\")\nprintln(\"Minimum radius    : $min_radius m\")","category":"page"},{"location":"tutorial/#Face-Visibility-Analysis","page":"Tutorial","title":"Face Visibility Analysis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Load shape with face visibility computation\nshape_vis = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_face_visibility=true)\n\n# Or build visibility graph for existing shape\nbuild_face_visibility_graph!(shape)\n\n# Access visibility data for a specific face\nface_id = 100\nvisible_faces = get_visible_face_indices(shape.face_visibility_graph, face_id)\nview_factors = get_view_factors(shape.face_visibility_graph, face_id)\nnum_visible = num_visible_faces(shape.face_visibility_graph, face_id)\n\nprintln(\"Face $face_id can see $num_visible other faces.\")\nprintln(\"Total view factor: \", sum(view_factors))\n\n# Check if a face is illuminated by the sun\nsun_position = SA[1.5e11, 0.0, 0.0]  # Sun 1 au away along x-axis\n\n# Without self-shadowing (pseudo-convex model)\nilluminated = isilluminated(shape, sun_position, face_id; with_self_shadowing=false)\nprintln(\"Face $face_id is \", illuminated ? \"illuminated\" : \"in shadow\")\n\n# With self-shadowing (requires `face_visibility_graph` to be built)\nilluminated = isilluminated(shape_vis, sun_position, face_id; with_self_shadowing=true)\nprintln(\"Face $face_id is \", illuminated ? \"illuminated\" : \"in shadow\")","category":"page"},{"location":"tutorial/#Batch-Illumination-Updates","page":"Tutorial","title":"Batch Illumination Updates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Efficiently update illumination state for all faces\nilluminated = Vector{Bool}(undef, length(shape.faces))\n\n# Without self-shadowing (fast, pseudo-convex model)\nupdate_illumination!(illuminated, shape, sun_position; with_self_shadowing=false)\nn_illuminated = count(illuminated)\nprintln(\"$n_illuminated faces are illuminated (pseudo-convex model).\")\n\n# With self-shadowing (requires `face_visibility_graph` to be built)\nupdate_illumination!(illuminated, shape_vis, sun_position; with_self_shadowing=true)\nn_illuminated = count(illuminated)\nprintln(\"$n_illuminated faces are illuminated (with self-shadowing).\")","category":"page"},{"location":"tutorial/#Binary-Asteroid-Shadowing","page":"Tutorial","title":"Binary Asteroid Shadowing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# For binary asteroid systems, check mutual shadowing effects\n# Assume we have two shape models: shape1 (primary) and shape2 (secondary)\nshape1 = load_shape_obj(\"primary_shape.obj\"; scale=1000, with_face_visibility=true, with_bvh=true)\nshape2 = load_shape_obj(\"secondary_shape.obj\"; scale=1000, with_face_visibility=true, with_bvh=true)\n\n# Define relative position and orientation\n# R12: rotation from shape1 frame to shape2 frame\n# R21: rotation from shape2 frame to shape1 frame\n# t12: translation from shape1 origin to shape2 origin\n# t21: translation from shape2 origin to shape1 origin\nR12 = SA[1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]  # Identity (no rotation)\nt12 = SA[2000.0, 0.0, 0.0]  # 2 km separation\n\nR21 = R12'         # Inverse rotation\nt21 = -R12' * t12  # Inverse translation\n\n# Sun position in each body's frame\nsun_position1 = SA[1.5e11, 0.0, 0.0]\nsun_position2 = sun_position1 - t12  # Transform to shape2's frame\n\n# First, check self-shadowing for each body\nilluminated1 = Vector{Bool}(undef, length(shape1.faces))\nilluminated2 = Vector{Bool}(undef, length(shape2.faces))\nupdate_illumination!(illuminated1, shape1, sun_position1; with_self_shadowing=true)\nupdate_illumination!(illuminated2, shape2, sun_position2; with_self_shadowing=true)\n\n# Then apply mutual shadowing\nstatus1 = apply_eclipse_shadowing!(illuminated1, shape1, sun_position1, R12, t12, shape2)\nstatus2 = apply_eclipse_shadowing!(illuminated2, shape2, sun_position2, R21, t21, shape1)\n\n# Check eclipse status\nif status1 == NO_ECLIPSE\n    println(\"Primary is not eclipsed by secondary.\")\nelseif status1 == PARTIAL_ECLIPSE\n    println(\"Primary is partially eclipsed by secondary.\")\nelseif status1 == TOTAL_ECLIPSE\n    println(\"Primary is totally eclipsed by secondary.\")\nend","category":"page"},{"location":"tutorial/#Ray-Shape-Intersection","page":"Tutorial","title":"Ray-Shape Intersection","text":"","category":"section"},{"location":"tutorial/#Single-Ray","page":"Tutorial","title":"Single Ray","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Ensure BVH is built for ray intersection\nif isnothing(shape.bvh)\n    build_bvh!(shape)\nend\n\n# Define a ray\norigin = SA[1000.0, 0.0, 0.0]  # Start 1 km away\ndirection = normalize(SA[-1.0, 0.0, 0.0])  # Point toward origin\nray = Ray(origin, direction)\n\n# Find intersection with shape\nresult = intersect_ray_shape(ray, shape)\n\nif result.hit\n    println(\"Ray hit face $(result.face_idx) at distance $(result.distance).\")\n    println(\"Hit point: \", result.point)\nelse\n    println(\"Ray missed the shape.\")\nend","category":"page"},{"location":"tutorial/#Batch-Ray-Processing","page":"Tutorial","title":"Batch Ray Processing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Process multiple rays efficiently\nrays = [Ray(SA[x, 0.0, 1000.0], SA[0.0, 0.0, -1.0]) for x in -500:100:500]\nresults = intersect_ray_shape(rays, shape)\n\n# Count hits\nn_hits = count(r -> r.hit, results)\nprintln(\"$n_hits out of $(length(rays)) rays hit the shape.\")\n\n# Process rays in a grid pattern\nray_grid = [Ray(SA[x, y, 1000.0], SA[0.0, 0.0, -1.0]) \n            for x in -500:100:500, y in -500:100:500]\nresult_grid = intersect_ray_shape(ray_grid, shape)\n\n# Results maintain the same shape as input\n@assert size(result_grid) == size(ray_grid)\n\n# Alternative: Use matrix interface for maximum performance\nn_rays = 100\norigins = rand(3, n_rays) .* 2000 .- 1000  # Random origins\ndirections = normalize.(eachcol(rand(3, n_rays) .- 0.5))\ndirections = hcat(directions...)  # Convert back to matrix\n\nresults = intersect_ray_shape(shape, origins, directions)","category":"page"},{"location":"tutorial/#Performance-Tips","page":"Tutorial","title":"Performance Tips","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use StaticArrays: All vector operations use SVector for performance\nBatch operations: Process multiple rays together using vector/matrix interfaces:\nintersect_ray_shape(rays::Vector{Ray}, shape) for ray collections\nintersect_ray_shape(rays::Matrix{Ray}, shape) preserves grid structure\nintersect_ray_shape(shape, origins, directions) for maximum performance\nBVH acceleration: Must be pre-built using build_bvh!(shape) or with_bvh=true when loading a shape model\nScale appropriately: Use consistent units (typically meters)\nPrecompute visibility: Use with_face_visibility=true when loading if you need visibility analysis\nAccess patterns: The face visibility graph uses CSR format - sequential access is faster than random","category":"page"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See the API Reference pages for detailed function documentation\nCheck the test suite for more examples\nExplore integration with SPICE.jl for ephemeris data","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#FaceVisibilityGraph-Performance-Benchmark-Results-(v0.2.0)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"This document records the performance comparison between the legacy adjacency list implementation and the new CSR-style FaceVisibilityGraph implementation introduced in PR #12.","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Test-Environment","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Test Environment","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Date: December 2024\nJulia Version: 1.11.5\nMachine: Apple M1/M2 (specify your machine)\nCommit: cae08e7 (feature/face-visibility-graph)","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Benchmark-Results","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Benchmark Results","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#1.-Small-Model-(Ryugu-test-shape-5,932-faces)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"1. Small Model (Ryugu test shape - 5,932 faces)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Visibility-Computation-Time","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Visibility Computation Time","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy implementation: 391.08 ms\nFaceVisibilityGraph:   97.51 ms\nSpeed up: 4.01x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Memory-Usage","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy (adjacency list): 11.7 MB\nFaceVisibilityGraph:     5.9 MB\nMemory reduction: 49.6%","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#2.-Large-Model-(Ryugu-49k-49,152-faces)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"2. Large Model (Ryugu 49k - 49,152 faces)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Visibility-Computation-Time-2","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Visibility Computation Time","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy implementation: 29.064 seconds\nFaceVisibilityGraph:   28.778 seconds\nSpeed up: 1.01x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Memory-Usage-2","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy (adjacency list): 561.92 MB\nFaceVisibilityGraph:     281.34 MB\nMemory reduction: 49.9%","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Query-Performance-(isilluminated-1000-queries)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Query Performance (isilluminated - 1000 queries)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Legacy implementation: 52.88 μs\nFaceVisibilityGraph:   49.67 μs\nSpeed ratio: 1.06x","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Verification-of-Results","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Verification of Results","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Computation-Results-Match","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Computation Results Match","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"All tests confirm that both implementations produce identical results:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"✅ Same number of visible face pairs\n✅ Same view factors (floating point equality)\n✅ Same distances\n✅ Same direction vectors\n✅ Same isilluminated results","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Test-Code-for-Verification","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Test Code for Verification","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"# From test/test_face_visibility_graph.jl (v0.2.1)\n@testset \"Legacy vs New Implementation\" begin\n    # Legacy implementation (v0.2.0)\n    shape_legacy = ShapeModel(nodes, faces)\n    find_visiblefacets!(shape_legacy, use_visibility_graph=false)\n    \n    # New implementation (v0.2.1)\n    shape_new = ShapeModel(nodes, faces)\n    find_visiblefacets!(shape_new, use_visibility_graph=true)\n    \n    for i in 1:length(faces)\n        @test length(legacy_visible) == length(new_visible)\n        @test sort(legacy_ids) == sort(new_ids)\n        # View factors, distances, and directions also match\n    end\nend","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Note: This comparison code was used in v0.2.1. In v0.3.0, the legacy implementation was completely removed.","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Key-Findings","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Key Findings","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"Small models (< 10k faces): Significant speedup (4x) due to reduced overhead\nLarge models (> 40k faces): Similar computation time, but 50% memory savings\nConsistent memory reduction: ~50% across all model sizes\nCache efficiency: Better sequential access patterns with CSR format","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Reproducing-These-Benchmarks","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Reproducing These Benchmarks","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"To reproduce these benchmarks on future versions:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"# Checkout the commit before FaceVisibilityGraph\ngit checkout e3529d2\n\n# Run legacy benchmark\njulia --project=. benchmark/compare_visibility.jl\n\n# Checkout the commit with FaceVisibilityGraph\ngit checkout feature/face-visibility-graph\n\n# Run comparison benchmark\njulia --project=. benchmark/compare_visibility.jl\njulia --project=. benchmark/benchmark_49k_shape.jl","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Migration-Notes","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Migration Notes","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Changes-in-v0.3.0","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Changes in v0.3.0","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"The following breaking changes were made in v0.3.0:","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"The use_visibility_graph parameter was removed (FaceVisibilityGraph is now always used)\nThe visiblefacets field was removed from ShapeModel\nfind_visiblefacets! was renamed to build_face_visibility_graph!\nvisibility_graph was renamed to face_visibility_graph\nThe find_visible_facets parameter in ShapeModel constructor was renamed to with_face_visibility\nAccessor functions were renamed:\nget_visible_faces → get_visible_face_indices\n(other accessors remain the same)","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/#Current-API-(v0.3.0)","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"Current API (v0.3.0+)","text":"","category":"section"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"# Create shape with face visibility\nshape = ShapeModel(nodes, faces; with_face_visibility=true)\n\n# Or load from OBJ file with visibility\nshape = load_shape_obj(\"path/to/shape.obj\"; scale=1000, with_face_visibility=true)\n\n# Or build visibility graph later\nbuild_face_visibility_graph!(shape)\n\n# Access visibility data\nvisible_indices = get_visible_face_indices(shape.face_visibility_graph, face_id)\nview_factors = get_view_factors(shape.face_visibility_graph, face_id)\ndistances = get_visible_face_distances(shape.face_visibility_graph, face_id)\ndirections = get_visible_face_directions(shape.face_visibility_graph, face_id)\n\n# Get specific visible face data\nvf_data = get_visible_face_data(shape.face_visibility_graph, face_id, visible_face_id)\n\n# Count visible faces\nn_visible = num_visible_faces(shape.face_visibility_graph, face_id)","category":"page"},{"location":"benchmarks/v0.2.0_face_visibility_graph/","page":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","title":"FaceVisibilityGraph Performance Benchmark Results (v0.2.0)","text":"These benchmark results serve as the baseline for future optimizations.","category":"page"}]
}
